import { a as debug } from './utils-e6b73120.js';
import { c as createStore } from './index-628f294a.js';

var ErrorCategory;
(function (ErrorCategory) {
    ErrorCategory["Component"] = "component";
    ErrorCategory["Api"] = "api";
    ErrorCategory["Auth"] = "auth";
})(ErrorCategory || (ErrorCategory = {}));
var ComponentErrorType;
(function (ComponentErrorType) {
    ComponentErrorType["endtime_not_in_future"] = "endtime_not_in_future";
    ComponentErrorType["no_booking_info"] = "no_booking_info";
    ComponentErrorType["no_timeslot_selected"] = "no_timeslot_selected";
    ComponentErrorType["no_timezone_selected"] = "no_timezone_selected";
    ComponentErrorType["no_booking_id"] = "no_booking_id";
    ComponentErrorType["invalid_start_time"] = "invalid_start_time";
    ComponentErrorType["invalid_end_time"] = "invalid_end_time";
    ComponentErrorType["invalid_timezone"] = "invalid_timezone";
})(ComponentErrorType || (ComponentErrorType = {}));
var APIErrorType;
(function (APIErrorType) {
    APIErrorType["invalid_session"] = "invalid_session";
    APIErrorType["general_error"] = "general_error";
    APIErrorType["internal_error"] = "internal_error";
    APIErrorType["invalid_request_error"] = "invalid_request_error";
    APIErrorType["timeslot_not_available"] = "timeslot_not_available";
})(APIErrorType || (APIErrorType = {}));
class Errors {
    constructor() {
        this.component = (_title) => {
            const category = ErrorCategory.Component;
            const title = `${_title} error`;
            return {
                endtime_not_in_future: (message = '"endtime" can not be in the future') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                no_booking_info: (message = 'No booking info provided') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                no_timeslot_selected: (message = 'No timeslot selected') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                no_timezone_selected: (message = 'No timezone selected') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                no_booking_id: (message = 'No booking id provided') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                invalid_start_time: (message = 'Invalid start time') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                invalid_end_time: (message = 'Invalid end time') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                invalid_timezone: (message = 'Invalid timezone') => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
            };
        };
        this.api = (_title) => {
            const category = ErrorCategory.Api;
            const title = `${_title} error`;
            return {
                invalid_session: (message) => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                general_error: (message) => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                internal_error: (message) => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                invalid_request_error: (message) => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
                timeslot_not_available: (message) => {
                    return {
                        title,
                        message,
                        category,
                    };
                },
            };
        };
    }
}

class NylaSchedulerAPIConnector {
    constructor({ schedulerAPIURL, schedulerStore, sessionId, configId }) {
        this.errors = new Errors();
        this.schedulerStore = schedulerStore;
        this.schedulerAPIURL = schedulerAPIURL;
        this.sessionId = sessionId;
        this.configId = configId;
    }
    getHeaders() {
        return !this.configId
            ? {
                Authorization: `Bearer ${this.sessionId}`,
            }
            : {};
    }
    async makeAPIRequest(path, method, body, headers = {}) {
        try {
            const schedulerURL = new URL(this.schedulerAPIURL);
            schedulerURL.pathname = path;
            const response = await fetch(decodeURIComponent(schedulerURL.toString()), {
                method,
                headers: {
                    'Content-Type': 'application/json',
                    'Origin': window.location.origin,
                    ...headers,
                },
                body,
            });
            const data = await response.json();
            return data;
        }
        catch (error) {
            return {
                error: {
                    message: error.message,
                    title: 'API request failed',
                    type: 'api',
                },
            };
        }
    }
    selectDate(date) {
        this.schedulerStore.set('selectedDate', date);
        this.schedulerStore.set('selectedTimeslot', null);
    }
    selectTime(time) {
        this.schedulerStore.set('selectedTimeslot', time);
    }
    selectTimezone(timezone) {
        this.schedulerStore.set('selectedTimezone', timezone);
    }
    toggleAdditionalData(value) {
        this.schedulerStore.set('showBookingForm', value);
    }
    setParticipantName(name) {
        const { bookingInfo } = this.schedulerStore.state;
        this.schedulerStore.set('bookingInfo', {
            ...bookingInfo,
            primaryParticipant: {
                ...bookingInfo?.primaryParticipant,
                name,
            },
        });
    }
    setParticipantEmail(email) {
        const { bookingInfo } = this.schedulerStore.state;
        this.schedulerStore.set('bookingInfo', {
            ...bookingInfo,
            primaryParticipant: {
                ...bookingInfo?.primaryParticipant,
                email,
            },
        });
    }
    async resetStoreStateAndFetchAvailability() {
        const today = new Date();
        const startTime = new Date(today.getFullYear(), today.getMonth(), 1).getTime() / 1000;
        const endTime = new Date(today.getFullYear(), today.getMonth() + 1, 1).getTime() / 1000;
        const result = await this.getAvailability(startTime, endTime);
        const firstAvailableDate = this.schedulerStore.get('availability').find((timeslot) => new Date(timeslot.start_time) > new Date());
        let _selectedDate = today;
        if (firstAvailableDate) {
            _selectedDate = firstAvailableDate.start_time;
        }
        this.schedulerStore.set('selectedDate', _selectedDate);
        this.schedulerStore.set('eventInfo', null);
        this.schedulerStore.set('showBookingForm', false);
        this.schedulerStore.set('selectedTimeslot', null);
        return result;
    }
    async setReschedule(bookingID) {
        const result = await this.resetStoreStateAndFetchAvailability();
        this.schedulerStore.set('rescheduleBookingId', bookingID);
        return result;
    }
    async setCancel(bookingID) {
        this.schedulerStore.set('cancelBookingId', bookingID);
    }
    async resetCancel() {
        const result = await this.resetStoreStateAndFetchAvailability();
        this.schedulerStore.set('cancelBookingId', '');
        this.schedulerStore.set('cancelledEventInfo', null);
        return result;
    }
    async bookTimeslot(data) {
        this.schedulerStore.set('isLoading', true);
        const { selectedTimeslot, selectedTimezone, bookingInfo } = this.schedulerStore.state;
        if (!data && !bookingInfo) {
            return { error: this.errors.component('Booking').no_booking_info() };
        }
        const timeslot = data?.timeslot || selectedTimeslot;
        if (!timeslot) {
            return { error: this.errors.component('Create Booking').no_timeslot_selected() };
        }
        const timezone = data && data?.timezone ? data?.timezone : selectedTimezone;
        if (!timezone) {
            return { error: this.errors.component('Create Booking').no_timezone_selected() };
        }
        const primaryParticipant = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;
        const guests = data ? data?.guests || [] : bookingInfo?.guests || [];
        const additional_fields = data ? { ...data?.additionalFields, guests } : { ...bookingInfo?.additionalFields, guests };
        const headers = this.getHeaders();
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/bookings${configIdParam}`;
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'POST', JSON.stringify({
            additional_fields,
            guest: { ...primaryParticipant },
            start_time: timeslot.start_time.getTime() / 1000,
            end_time: timeslot.end_time.getTime() / 1000,
            timezone: timezone,
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Create Booking')) {
                error = this.errors.api('Create Booking')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        if ('data' in response) {
            this.schedulerStore.set('eventInfo', response?.data);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async getUISettings() {
        this.schedulerStore.set('isLoading', true);
        const headers = this.getHeaders();
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/ui-settings${configIdParam}`;
        const response = await this.makeAPIRequest(url, 'GET', undefined, headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Get UI Settings')) {
                error = this.errors.api('Get UI Settings')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        if ('data' in response) {
            this.schedulerStore.set('configSettings', response.data);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async getAvailability(startTime = 0, endTime = 0) {
        this.schedulerStore.set('isLoading', true);
        const params = new URLSearchParams();
        const now = new Date();
        const nowTime = now.getTime();
        if (endTime && endTime < nowTime / 1000) {
            this.schedulerStore.set('isLoading', false);
            const error = this.errors.component('Get Availability').endtime_not_in_future();
            return { error };
        }
        if (!startTime) {
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
            startTime = Math.floor(startOfMonth.getTime() / 1000);
        }
        if (!endTime) {
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            endTime = Math.floor(endOfMonth.getTime() / 1000);
        }
        params.append('start_time', encodeURIComponent(startTime.toString()));
        params.append('end_time', encodeURIComponent(endTime.toString()));
        if (this.configId) {
            params.append('configuration_id', encodeURIComponent(this.configId));
        }
        const queryString = params.toString();
        const url = `/v3/scheduling/availability${queryString ? `?${queryString}` : ''}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'GET', undefined, headers);
        if ('error' in response) {
            this.schedulerStore.set('availability', []);
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Get Availability')) {
                error = this.errors.api('Get Availability')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        if ('data' in response) {
            const availability = response.data?.time_slots?.map(timeslot => {
                return {
                    ...timeslot,
                    start_time: new Date(timeslot.start_time * 1000),
                    end_time: new Date(timeslot.end_time * 1000),
                };
            }) || [];
            const availabilityTimeslotsFiltered = availability.filter(timeslot => timeslot.start_time.getTime() > nowTime);
            this.schedulerStore.set('availability', availabilityTimeslotsFiltered);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async cancelBooking(bookingId) {
        this.schedulerStore.set('isLoading', true);
        if (!bookingId) {
            return { error: this.errors.component('Cancel Booking').no_booking_id() };
        }
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'DELETE', JSON.stringify({
            action: 'cancel',
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Cancel Booking')) {
                error = this.errors.api('Cancel Booking')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        this.schedulerStore.set('cancelledEventInfo', {
            booking_id: bookingId,
        });
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async rescheduleBooking(bookingId, data) {
        this.schedulerStore.set('isLoading', true);
        if (!bookingId) {
            return { error: this.errors.component('Reschedule Booking').no_booking_id() };
        }
        const apiErrors = this.errors.api('Reschedule Booking');
        const componentErrors = this.errors.component('Reschedule Booking');
        const { bookingInfo, selectedTimeslot, selectedTimezone } = this.schedulerStore.state;
        const { startTime, endTime, timezone } = data;
        const start_time = startTime || selectedTimeslot?.start_time;
        if (!start_time) {
            return { error: componentErrors.invalid_start_time('Please pass "startTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
        }
        const end_time = endTime || selectedTimeslot?.end_time;
        if (!end_time) {
            return { error: componentErrors.invalid_end_time('Please pass "endTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
        }
        const time_zone = timezone || selectedTimezone;
        if (!time_zone) {
            return { error: componentErrors.invalid_timezone('Please pass "timezone" in data or set "selectedTimezone" in the defaultSchedulerState.') };
        }
        const primaryParticipant = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;
        const guests = data ? data?.guests || [] : bookingInfo?.guests || [];
        const additional_fields = data ? { ...data?.additionalFields, guests } : { ...bookingInfo?.additionalFields, guests };
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'PATCH', JSON.stringify({
            start_time: start_time.getTime() / 1000,
            end_time: end_time.getTime() / 1000,
            time_zone,
            additional_fields,
            guest: { ...primaryParticipant },
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in apiErrors) {
                error = apiErrors[errorType](error?.message || error?.title || 'Something went wrong');
            }
        }
        if ('data' in response)
            this.schedulerStore.set('eventInfo', response?.data);
        this.schedulerStore.set('isLoading', false);
        return response;
    }
}

function CreateNylasSchedulerStore(defaultState = {}) {
    const defaultNylasStoreState = {
        selectedDate: null,
        selectedLanguage: navigator.language,
        selectedTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        selectedTimeslot: null,
        showBookingForm: false,
        selectableDates: null,
        availability: [],
        state: 'ready',
        eventInfo: null,
        cancelledEventInfo: null,
        isLoading: false,
        nylasBranding: true,
        ...defaultState,
    };
    debug(`[defaultNylasStoreState]: `, defaultNylasStoreState);
    const store = createStore(defaultNylasStoreState);
    store.onChange('availability', availability => {
        debug(`[availability]: `, availability);
        const selectableDates = availability.map(timeslot => timeslot.start_time);
        debug(`[selectableDates]: `, selectableDates);
        store.set('selectableDates', selectableDates);
    });
    store.reset = () => {
        for (const key in defaultNylasStoreState) {
            const value = defaultNylasStoreState[key];
            store.set(key, value);
        }
    };
    return store;
}

export { CreateNylasSchedulerStore as C, ErrorCategory as E, NylaSchedulerAPIConnector as N };

//# sourceMappingURL=scheduler-store-8ca9003d.js.map