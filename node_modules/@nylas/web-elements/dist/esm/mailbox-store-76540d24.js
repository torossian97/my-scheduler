import { a as debug } from './utils-e6b73120.js';
import { X as Xr, Z as Zr } from './index.es-be19d2df.js';
import { c as createStore } from './index-628f294a.js';

class NylasAuthConnector {
    constructor(nylasAuth, nylasAuthStore) {
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
    }
    async validateSession() {
        const isAuthenticated = await this.isAccessTokenValid();
        if (!isAuthenticated) {
            this.logout();
        }
        else {
            let tokenInfo = await this.nylasAuth.getTokenInfo();
            if (tokenInfo) {
                const expireTimeCheck = 5 * 60 * 1000;
                const currentTimeInSeconds = Math.floor(Date.now() / 1000);
                if (tokenInfo.expires_in && tokenInfo.expires_in - currentTimeInSeconds < expireTimeCheck) {
                    debug('[NylasAuthConnectorMixin] Refreshing access token');
                    tokenInfo = await this.nylasAuth.refreshAccessToken();
                    if (!tokenInfo) {
                        debug('[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out.');
                        this.logout();
                        return;
                    }
                }
                this.nylasAuthStore.state.tokenInfo = tokenInfo;
            }
        }
        this.nylasAuthStore.state.isAuthenticated = isAuthenticated;
    }
    async isAuthenticated() {
        return this.nylasAuth.isAuthenticated();
    }
    async getTokenInfo() {
        return this.nylasAuth.getTokenInfo();
    }
    async isAccessTokenValid() {
        return this.nylasAuth.isAccessTokenValid();
    }
    async logout() {
        await this.nylasAuth.logout();
    }
    async getHostedAuthRedirectURL(scopes, email, provider) {
        return this.nylasAuth.getHostedAuthRedirectURL(scopes, email, provider);
    }
    async manageHostedAuthCodeExchange(currentUrl) {
        const url = new URL(currentUrl);
        const code = url.searchParams.get('code');
        if (code) {
            const tokenInfo = await this.nylasAuth.exchangeAuthCodeForTokenInfo(code);
            if (tokenInfo) {
                this.nylasAuthStore.state.tokenInfo = tokenInfo;
                this.nylasAuthStore.state.isAuthenticated = true;
                return tokenInfo;
            }
        }
        return null;
    }
}

class NylasMessagesConnector {
    constructor(nylasAuth, nylasAuthStore, nylasMailboxStore) {
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
        this.nylasMailboxStore = nylasMailboxStore;
    }
    async getMessages() {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        this.nylasMailboxStore.state.state = 'loading';
        const queryParams = this.nylasMailboxStore.state.messgeQueryParams;
        const params = new URLSearchParams();
        for (const key in queryParams) {
            const value = queryParams[key]?.toString();
            if (value) {
                params.append(key, value);
            }
        }
        const path = `/v3/grants/me/messages?${params.toString()}`;
        const response = await this.nylasAuth.nylasAPIRequest(path);
        if (Xr(response)) {
            throw new Zr(response.error);
        }
        const messages = response.data;
        this.nylasMailboxStore.state.messages = messages;
        this.nylasMailboxStore.state.state = 'ready';
        return messages;
    }
    async getThreadMessages(threadId) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        const response = await this.nylasAuth.nylasAPIRequest(`/v3/grants/me/messages?thread_id=${threadId}&fields=include_headers`);
        if (Xr(response)) {
            throw new Zr(response.error);
        }
        const messages = response.data;
        this.nylasMailboxStore.state.messages = messages;
        return messages;
    }
    downloadMessageAttachments(message) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        const blobPromises = [];
        const attachments = message.attachments || [];
        for (const attachment of attachments) {
            const blob = this.nylasAuth.nylasDownloadFileRequest(`/v3/grants/me/attachments/${attachment.id}?message_id=${message.id}`);
            blobPromises.push(blob);
        }
        return blobPromises;
    }
    async summarizeText(text) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        const response = await this.nylasAuth.nylasAPIRequest(`/v3/grants/me/mailbox/summarize`, 'POST', {
            message: {
                body: text,
            },
        }, true, this.nylasAuth.config.elementsApiUri);
        if (Xr(response)) {
            throw new Zr(response.error);
        }
        return response.data.summary;
    }
    async textToSpeech(text, abortController) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        return this.nylasAuth.nylasAPIRequest(`/v3/grants/me/mailbox/tts`, 'POST', {
            text,
        }, false, this.nylasAuth.config.elementsApiUri, {
            ...(abortController ? { signal: abortController?.signal } : {}),
        });
    }
}

class NylasThreadsConnector {
    constructor(nylasAuth, nylasAuthStore, nylasMailboxStore, router) {
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
        this.nylasMailboxStore = nylasMailboxStore;
        this.router = router;
    }
    async getThreads(overrideQueryParams, updateMethod = 'overwrite', updateState = true) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing thread:read-only scope');
        }
        if (updateState) {
            this.nylasMailboxStore.state.state = 'loading';
        }
        const queryParams = overrideQueryParams || this.nylasMailboxStore.state.threadsQueryParams;
        const params = new URLSearchParams();
        for (const key in queryParams) {
            const value = queryParams[key]?.toString();
            if (typeof value !== 'undefined' && value !== null) {
                params.append(key, value);
            }
        }
        if (queryParams.search_query_native) {
            this.router.navigate(`/?query=${queryParams.search_query_native}`, true);
        }
        else if (this.nylasMailboxStore.state.threadsQueryParams.search_query_native && !queryParams.search_query_native) {
            this.router.navigate('/', true);
        }
        if (!queryParams.page_token) {
            this.nylasMailboxStore.state.previousThreadPageTokens = [];
        }
        this.nylasMailboxStore.state.threadsQueryParams = queryParams;
        const path = `/v3/grants/me/threads?${params.toString()}`;
        const response = await this.nylasAuth.nylasAPIRequest(path);
        if (Xr(response)) {
            throw new Zr(response.error);
        }
        const threads = response.data;
        switch (updateMethod) {
            case 'prepend':
                this.nylasMailboxStore.state.threads = [...threads, ...this.nylasMailboxStore.state.threads];
                break;
            case 'append':
                this.nylasMailboxStore.state.threads = [...this.nylasMailboxStore.state.threads, ...threads];
                break;
            case 'overwrite':
            default:
                this.nylasMailboxStore.state.threads = threads;
                break;
        }
        if (response.next_cursor) {
            this.nylasMailboxStore.state.nextThreadPageToken = response.next_cursor;
        }
        else {
            this.nylasMailboxStore.state.nextThreadPageToken = null;
        }
        if (updateState) {
            this.nylasMailboxStore.state.state = 'ready';
        }
        return threads;
    }
    async getThread(threadId) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing thread:read-only scope');
        }
        const storeThread = this.nylasMailboxStore.state.threads.find(t => t.id === threadId);
        if (storeThread) {
            return storeThread;
        }
        this.nylasMailboxStore.state.state = 'loading';
        const path = `/v3/grants/me/threads/${threadId}`;
        const response = await this.nylasAuth.nylasAPIRequest(path);
        if (Xr(response)) {
            throw new Zr(response.error);
        }
        const thread = response.data;
        this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {
            if (t.id === thread.id) {
                return thread;
            }
            return t;
        });
        this.nylasMailboxStore.state.state = 'ready';
        return thread;
    }
    async nextThreadPage(updateMethod = 'overwrite', updateLoadingState = true) {
        if (!this.nylasMailboxStore.state.nextThreadPageToken) {
            throw new Error('No next page token');
        }
        this.nylasMailboxStore.state.previousThreadPageTokens = Array.from(new Set([...this.nylasMailboxStore.state.previousThreadPageTokens, this.nylasMailboxStore.state.threadsQueryParams.page_token ?? null]));
        const nextPageToken = this.nylasMailboxStore.state.nextThreadPageToken;
        return this.getThreads({
            ...this.nylasMailboxStore.state.threadsQueryParams,
            page_token: nextPageToken,
        }, updateMethod, updateLoadingState);
    }
    async previousThreadPage(aupdateMethod = 'overwrite', updateLoadingState = true) {
        if (!this.nylasMailboxStore.state.previousThreadPageTokens.length) {
            throw new Error('No previous page token');
        }
        const previousThreadPageTokens = [...this.nylasMailboxStore.state.previousThreadPageTokens];
        const pageToken = previousThreadPageTokens.pop();
        this.nylasMailboxStore.state.previousThreadPageTokens = previousThreadPageTokens;
        return this.getThreads({
            ...this.nylasMailboxStore.state.threadsQueryParams,
            page_token: pageToken ?? undefined,
        }, aupdateMethod, updateLoadingState);
    }
    updateThreadQueryParams(params) {
        this.nylasMailboxStore.state.threadsQueryParams = {
            ...this.nylasMailboxStore.state.threadsQueryParams,
            ...params,
        };
    }
    back() {
        this.router.navigate('/', true);
        this.nylasMailboxStore.state.selectedThread = null;
    }
    unSelectThread() {
        this.nylasMailboxStore.state.selectedThread = null;
    }
    async selectThread(thread) {
        this.router.navigate(`/thread/${thread.id}`, true);
        this.nylasMailboxStore.state.selectedThread = thread;
        if (thread.unread) {
            this.markThreadAsRead(thread).catch(error => {
                debug('Error marking thread as read', error);
            });
        }
    }
    async markThreadAsRead(thread) {
        return this.updateThread(thread, { unread: false });
    }
    async updateThread(thread, updateThread) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', 'modify')) {
            throw new Error('Missing thread:modify scope');
        }
        const path = `/v3/grants/me/threads/${thread.id}`;
        const response = await this.nylasAuth.nylasAPIRequest(path, 'PUT', updateThread);
        if (Xr(response)) {
            throw new Zr(response.error);
        }
        const updatedThread = response.data;
        this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {
            if (t.id === updatedThread.id) {
                return updatedThread;
            }
            return t;
        });
        this.nylasMailboxStore.state.selectedThread = updatedThread;
        return updatedThread;
    }
}

class NylasFoldersConnector {
    constructor(nylasAuth, nylasAuthStore, nylasMailboxStore) {
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
        this.nylasMailboxStore = nylasMailboxStore;
    }
    async getFolders() {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing thread:read-only scope');
        }
        this.nylasMailboxStore.state.state = 'loading';
        const path = `/v3/grants/me/folders`;
        const response = await this.nylasAuth.nylasAPIRequest(path);
        if (Xr(response)) {
            throw new Zr(response.error);
        }
        const folders = response.data;
        this.nylasMailboxStore.state.folders = folders;
        this.nylasMailboxStore.state.state = 'ready';
        return folders;
    }
    async selectFolder(folder) {
        this.nylasMailboxStore.state.threadsQueryParams = {
            in: folder.id,
            ...(this.nylasMailboxStore.state.threadsQueryParams || {}),
        };
    }
}

class PolyFillHashChangeEvent extends Event {
    constructor(type, eventInitDict) {
        super(type, eventInitDict);
        this.oldURL = eventInitDict.oldURL;
        this.newURL = eventInitDict.newURL;
    }
}
class HashRouter {
    constructor() {
        this.routeChangeListeners = [];
        debug('HashRouter constructor');
    }
    destroy() {
        debug('HashRouter destroy');
        window.removeEventListener('hashchange', this.onRouteChange.bind(this));
    }
    init() {
        debug('HashRouter init');
        window.addEventListener('hashchange', this.onRouteChange.bind(this));
        if (typeof HashChangeEvent !== 'undefined') {
            const event = new HashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });
            this.onRouteChange(event);
        }
        else {
            const event = new PolyFillHashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });
            this.onRouteChange(event);
        }
    }
    addRouteChangeListener(route, listener) {
        debug('HashRouter addRouteChangeListener');
        this.routeChangeListeners.push([route, listener]);
    }
    navigate(route, shallow) {
        debug('HashRouter navigate');
        if (shallow) {
            return window.history.pushState(null, '', `#${route}`);
        }
        window.location.hash = route;
    }
    setRoute(route) {
        debug('HashRouter setRoute');
        window.location.hash = route;
    }
    matchRoute(route, path) {
        const routeParts = route.split('/');
        const pathParts = path.split('/');
        debug(`HashRouter matchRoute route=${route} path=${path}`, { routeParts, pathParts });
        if (routeParts[1] === '' && pathParts[0] === '') {
            return true;
        }
        if (routeParts.length !== pathParts.length) {
            return false;
        }
        for (let i = 0; i < routeParts.length; i++) {
            const routePart = routeParts[i];
            const pathPart = pathParts[i];
            if (routePart.startsWith(':')) {
                continue;
            }
            if (routePart !== pathPart) {
                return false;
            }
        }
        return true;
    }
    getRouteParams(route) {
        debug('HashRouter getRouteParams');
        const routeParams = {};
        const routeParts = route.split('/');
        const routeConfigParts = window.location.hash.split('/');
        routeParts.forEach((routePart, index) => {
            if (routePart.startsWith(':')) {
                const key = routePart.substring(1);
                routeParams[key] = routeConfigParts[index];
            }
        });
        return routeParams;
    }
    getRouteWithParams(route, routeParams) {
        debug('HashRouter getRouteWithParams');
        let routeWithParams = route;
        Object.keys(routeParams).forEach(key => {
            routeWithParams = routeWithParams.replace(`:${key}`, routeParams[key]);
        });
        return routeWithParams;
    }
    getRoute() {
        debug('HashRouter getRoute');
        return window.location.hash;
    }
    onRouteChange(event) {
        this.routeChangeListeners.forEach(async ([route, listener]) => {
            const path = event.newURL.indexOf('#') === -1 ? '' : event.newURL.substring(event.newURL.indexOf('#') + 1);
            debug(`HashRouter onRouteChange route=${route} path=${path}`, { event });
            if (!this.matchRoute(route, path)) {
                debug(`HashRouter onRouteChange route=${route} path=${path} does not match`);
                return;
            }
            const routeParams = this.getRouteParams(route);
            await listener(route, path, routeParams);
        });
    }
    getBasePath() {
        debug('HashRouter getBasePath');
        return '';
    }
}

function CreateNylasAuthStore(defaultState = {}) {
    const defaultNylasStoreState = {
        isAuthenticated: false,
        tokenInfo: null,
        state: 'ready',
        ...defaultState,
    };
    const store = createStore(defaultNylasStoreState);
    store.reset = () => {
        for (const key in defaultNylasStoreState) {
            const value = defaultNylasStoreState[key];
            store.set(key, value);
        }
    };
    return store;
}

function CreateNylasMailboxStore(defaultState = {}) {
    const defaultNylasStoreState = {
        state: 'ready',
        messages: [],
        threads: [],
        folders: [],
        selectedThread: null,
        nextThreadPageToken: null,
        previousThreadPageTokens: [],
        searchQuery: '',
        hasNextThreadPage: false,
        hasPreviousThreadPage: false,
        selectedFolder: 'inbox',
        threadsQueryParams: {
            in: 'inbox',
        },
        messgeQueryParams: {
            fields: 'include_headers',
        },
        ...defaultState,
    };
    const store = createStore({ ...defaultNylasStoreState });
    store.onChange('nextThreadPageToken', nextThreadPageToken => {
        store.set('hasNextThreadPage', nextThreadPageToken !== null);
    });
    store.onChange('previousThreadPageTokens', previousThreadPageTokens => {
        store.set('hasPreviousThreadPage', previousThreadPageTokens.length > 0);
    });
    store.onChange('threadsQueryParams', threadsQueryParams => {
        store.set('selectedFolder', threadsQueryParams.in || 'inbox');
        store.set('searchQuery', threadsQueryParams.search_query_native || '');
    });
    store.reset = () => {
        for (const key in defaultNylasStoreState) {
            const value = defaultNylasStoreState[key];
            store.set(key, value);
        }
    };
    return store;
}

export { CreateNylasAuthStore as C, HashRouter as H, NylasAuthConnector as N, NylasThreadsConnector as a, NylasMessagesConnector as b, NylasFoldersConnector as c, CreateNylasMailboxStore as d };

//# sourceMappingURL=mailbox-store-76540d24.js.map