'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-c14ea8f5.js');
const utils = require('./utils-85bd0909.js');
const _commonjsHelpers = require('./_commonjsHelpers-ef8cd0cd.js');

var customParseFormat$1 = {exports: {}};

(function (module, exports) {
!function(e,t){"object"=='object'&&"undefined"!='object'?module.exports=t():"function"==typeof undefined&&undefined.amd?undefined(t):(e="undefined"!=typeof globalThis?globalThis:e||self).dayjs_plugin_customParseFormat=t();}(_commonjsHelpers.commonjsGlobal,(function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},t=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d\d/,r=/\d\d?/,i=/\d*[^-_:/,()\s\d]+/,o={},s=function(e){return (e=+e)+(e>68?1900:2e3)};var a=function(e){return function(t){this[e]=+t;}},f=[/[+-]\d\d:?(\d\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if("Z"===e)return 0;var t=e.match(/([+-]|\d\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:"+"===t[0]?-n:n}(e);}],h=function(e){var t=o[e];return t&&(t.indexOf?t:t.s.concat(t.f))},u=function(e,t){var n,r=o.meridiem;if(r){for(var i=1;i<=24;i+=1)if(e.indexOf(r(i,0,t))>-1){n=i>12;break}}else n=e===(t?"pm":"PM");return n},d={A:[i,function(e){this.afternoon=u(e,!1);}],a:[i,function(e){this.afternoon=u(e,!0);}],S:[/\d/,function(e){this.milliseconds=100*+e;}],SS:[n,function(e){this.milliseconds=10*+e;}],SSS:[/\d{3}/,function(e){this.milliseconds=+e;}],s:[r,a("seconds")],ss:[r,a("seconds")],m:[r,a("minutes")],mm:[r,a("minutes")],H:[r,a("hours")],h:[r,a("hours")],HH:[r,a("hours")],hh:[r,a("hours")],D:[r,a("day")],DD:[n,a("day")],Do:[i,function(e){var t=o.ordinal,n=e.match(/\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\[|\]/g,"")===e&&(this.day=r);}],M:[r,a("month")],MM:[n,a("month")],MMM:[i,function(e){var t=h("months"),n=(h("monthsShort")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n;}],MMMM:[i,function(e){var t=h("months").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t;}],Y:[/[+-]?\d+/,a("year")],YY:[n,function(e){this.year=s(e);}],YYYY:[/\d{4}/,a("year")],Z:f,ZZ:f};function c(n){var r,i;r=n,i=o&&o.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var o=r&&r.toUpperCase();return n||i[r]||e[r]||i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),a=s.length,f=0;f<a;f+=1){var h=s[f],u=d[h],c=u&&u[0],l=u&&u[1];s[f]=l?{regex:c,parser:l}:h.replace(/^\[|\]$/g,"");}return function(e){for(var t={},n=0,r=0;n<a;n+=1){var i=s[n];if("string"==typeof i)r+=i.length;else {var o=i.regex,f=i.parser,h=e.slice(r),u=o.exec(h)[0];f.call(t,u),e=e.replace(u,"");}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon;}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(s=e.parseTwoDigitYear);var r=t.prototype,i=r.parse;r.parse=function(e){var t=e.date,r=e.utc,s=e.args;this.$u=r;var a=s[1];if("string"==typeof a){var f=!0===s[2],h=!0===s[3],u=f||h,d=s[2];h&&(d=s[2]),o=this.$locale(),!f&&d&&(o=n.Ls[d]),this.$d=function(e,t,n){try{if(["x","X"].indexOf(t)>-1)return new Date(("X"===t?1e3:1)*e);var r=c(t)(e),i=r.year,o=r.month,s=r.day,a=r.hours,f=r.minutes,h=r.seconds,u=r.milliseconds,d=r.zone,l=new Date,m=s||(i||o?1:l.getDate()),M=i||l.getFullYear(),Y=0;i&&!o||(Y=o>0?o-1:l.getMonth());var p=a||0,v=f||0,D=h||0,g=u||0;return d?new Date(Date.UTC(M,Y,m,p,v,D,g+60*d.offset*1e3)):n?new Date(Date.UTC(M,Y,m,p,v,D,g)):new Date(M,Y,m,p,v,D,g)}catch(e){return new Date("")}}(t,a,r),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),u&&t!=this.format(a)&&(this.$d=new Date("")),o={};}else if(a instanceof Array)for(var l=a.length,m=1;m<=l;m+=1){s[1]=a[m-1];var M=n.apply(this,s);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===l&&(this.$d=new Date(""));}else i.call(this,e);};}}));
}(customParseFormat$1, customParseFormat$1.exports));

const customParseFormat = customParseFormat$1.exports;

const nylasTimeWindowPickerCss = ":host{display:block;position:relative;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.time-picker{display:inline-block;width:150px;font-family:var(--nylas-font-family);position:relative}@media screen and (max-width: 768px){.time-picker{width:auto}}.time-picker input{width:150px;height:48px;text-align:center;font-size:16px;font-family:inherit;cursor:pointer;background:transparent;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x)}@media screen and (max-width: 768px){.time-picker input{width:88px}}@media screen and (max-width: 504px){.time-picker input{width:68px;font-size:15px}}.time-picker input.focus{background:transparent}.time-picker input:hover,.time-picker input:active{border:1px solid var(--nylas-primary)}.time-picker input:active{outline:2px solid var(--nylas-primary)}.time-picker input span.open{transform:rotate(90deg)}.time-picker input span.closed{transform:rotate(270deg)}.time-picker input.error{border:1px solid var(--nylas-error)}.time-picker p.error{color:var(--nylas-error);font-size:0.875rem;margin:0}.times{display:block;margin-top:0.5rem;background-color:var(--nylas-base-0);width:100%;max-height:336px;overflow:auto;border:1px solid #ddd;z-index:1;border-radius:4px;position:absolute;box-shadow:0px 4px 6px -2px rgba(0, 0, 0, 0.0509803922);box-shadow:0px 10px 15px -3px rgba(0, 0, 0, 0.1019607843)}.times ul{padding:0;list-style-type:none;color:var(--nylas-base-900);max-height:336px}.times ul li{padding:16px, 12px, 16px, 12px;color:black;padding:12px 16px;text-decoration:none;display:block;font-family:inherit;font-size:14px;font-weight:400;line-height:20px;letter-spacing:0px;text-align:center;cursor:pointer}.times ul li.focused{background-color:var(--nylas-base-100)}.times ul li:hover,.times ul li:focus{background-color:var(--nylas-base-100)}.times ul li label{display:flex;align-items:center;gap:0.5rem}.times ul li label input{margin:0}";

utils.dayjs.extend(customParseFormat);
const TimeInput = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.timeChange = index.createEvent(this, "timeChange", 7);
        this.formError = index.createEvent(this, "formError", 7);
        this.time = undefined;
        this.minimumStartTime = null;
        this.placeholder = 'hh:mmam/pm';
        this.name = undefined;
        this.hasError = false;
        this.err = '';
        this.showTimes = false;
        this.ariaActivedescendant = '';
        this.times = this.generateTimes();
        this.shouldAutoScroll = false;
    }
    handleOutsideClick(event) {
        const path = event.composedPath();
        const isClickInside = path.includes(this.el);
        if (!isClickInside && this.showTimes) {
            this.showTimes = false;
        }
    }
    minimumStartTimeChangedHandler() {
        if (this.minimumStartTime) {
            let formattedTime = utils.dayjs()
                .hour(parseInt(this.minimumStartTime))
                .minute(parseInt(this.minimumStartTime.slice(-4, -2)));
            if (this.minimumStartTime.slice(-2).toLowerCase() === 'pm' && parseInt(this.minimumStartTime) !== 12) {
                formattedTime = formattedTime.add(12, 'hour');
            }
            else if (this.minimumStartTime.slice(-2).toLowerCase() === 'am' && parseInt(this.minimumStartTime) === 12) {
                formattedTime = formattedTime.subtract(12, 'hour');
            }
            this.times = this.generateTimes();
            const firstTime = utils.dayjs(this.times[0].value, 'hh:mma');
            let selectedTimeFormatted = utils.dayjs(this.time, 'hh:mma');
            if (selectedTimeFormatted.isBefore(firstTime)) {
                this.err = 'Invalid';
                this.formError.emit({
                    key: this.el.id,
                    message: 'Invalid',
                });
            }
        }
    }
    componentDidRender() {
        if (this.showTimes && this.shouldAutoScroll) {
            const autocompletedTime = utils.autocompleteTimeFormat(this.time);
            const optionIndex = this.times.findIndex(time => time.value === autocompletedTime);
            if (optionIndex > -1) {
                this.shouldAutoScroll = false;
                this.scrollToViewWithinParent(optionIndex);
            }
            return;
        }
    }
    handleTimeChange(_e, input) {
        const timePart = input.split(':');
        if (timePart[0] === '00' && timePart[1].slice(-2) == 'pm') {
            this.err = 'Invalid';
            this.formError.emit({
                key: this.el.id,
                message: 'Invalid',
            });
        }
        if (!utils.validateTimeFormatInput(input)) {
            this.err = 'Invalid';
            this.formError.emit({
                key: this.el.id,
                message: 'Invalid',
            });
        }
        else {
            this.err = '';
            this.formError.emit({
                key: this.el.id,
                message: '',
            });
        }
        this.timeChange.emit({
            key: this.el.id,
            value: input,
        });
    }
    handleTimeAutocomplete(event) {
        const input = event.target?.value;
        if (!utils.validateTimeFormatInput(input)) {
            this.err = 'Invalid';
            this.formError.emit({
                key: this.el.id,
                message: 'Invalid',
            });
            return;
        }
        if (input === '') {
            const newTime = utils.roundToNearest15Minutes().format('hh:mma');
            this.timeChange.emit({
                key: this.el.id,
                value: newTime,
            });
            return;
        }
        if (!utils.validateExactTimeFormat(input)) {
            const autocompletedTime = utils.autocompleteTimeFormat(input);
            this.timeChange.emit({
                key: this.el.id,
                value: autocompletedTime,
            });
            return;
        }
        this.timeChange.emit({
            key: this.el.id,
            value: input,
        });
    }
    handleOnInput(event) {
        const input = event.target?.value;
        if (!utils.validateTimeFormatInput(input)) {
            return;
        }
        if (input === '') {
            const newTime = utils.roundToNearest15Minutes().format('hh:mma');
            const optionIndex = this.times.findIndex(time => time.value === newTime);
            if (optionIndex > -1) {
                this.scrollToViewWithinParent(optionIndex);
            }
            return;
        }
        if (!utils.validateExactTimeFormat(input)) {
            const autocompletedTime = utils.autocompleteTimeFormat(input);
            const optionIndex = this.times.findIndex(time => time.value === autocompletedTime);
            if (optionIndex > -1) {
                this.scrollToViewWithinParent(optionIndex);
            }
            return;
        }
    }
    generateTimes() {
        const times = [];
        let startTime = utils.dayjs().set('hour', 0).set('minute', 0).set('second', 0);
        if (this.minimumStartTime) {
            startTime = utils.dayjs(this.minimumStartTime, 'hh:mma');
        }
        const diff = startTime.endOf('day').diff(startTime, 'minutes');
        const iterations = Math.round(diff / 15);
        for (let i = 0; i < iterations + 1; i++) {
            const time = startTime.add(i * 15, 'minute');
            if (i == iterations && time.format('hh:mma').includes('am')) {
                break;
            }
            times.push({ id: i, value: time.format('hh:mma') });
        }
        return times;
    }
    handleComboboxKeyDown(event) {
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            if (!this.showTimes) {
                this.showTimes = true;
                this.shouldAutoScroll = true;
                return;
            }
            if (this.ariaActivedescendant === '') {
                this.ariaActivedescendant = this.times[0].id.toString();
                this.focusOption(0);
            }
            else {
                const currentIndex = this.times.findIndex(time => time.id.toString() === this.ariaActivedescendant);
                const nextIndex = currentIndex + 1 < this.times.length ? currentIndex + 1 : 0;
                this.ariaActivedescendant = this.times[nextIndex].id.toString();
                this.focusOption(nextIndex);
            }
        }
        else if (event.key === 'ArrowUp') {
            event.preventDefault();
            if (this.ariaActivedescendant === '') {
                this.ariaActivedescendant = this.times[this.times.length - 1].id.toString();
                this.focusOption(this.times.length - 1);
            }
            else {
                const currentIndex = this.times.findIndex(time => time.id.toString() === this.ariaActivedescendant);
                const prevIndex = currentIndex - 1 >= 0 ? currentIndex - 1 : this.times.length - 1;
                this.ariaActivedescendant = this.times[prevIndex].id.toString();
                this.focusOption(prevIndex);
            }
        }
        else if (event.key === 'Escape') {
            this.showTimes = false;
            this.timeInput.focus();
        }
    }
    handleListboxKeydown(e) {
        const items = this.times;
        const currentIndex = items.findIndex(item => item.id.toString() === this.ariaActivedescendant);
        if (e.key === 'ArrowDown' || (e.key === 'Tab' && !e.shiftKey)) {
            e.preventDefault();
            const nextIndex = currentIndex + 1 < items.length ? currentIndex + 1 : 0;
            this.ariaActivedescendant = items[nextIndex].id.toString();
            this.focusOption(nextIndex);
        }
        else if (e.key === 'ArrowUp' || (e.key === 'Tab' && e.shiftKey)) {
            e.preventDefault();
            const prevIndex = currentIndex - 1 >= 0 ? currentIndex - 1 : items.length - 1;
            this.ariaActivedescendant = items[prevIndex].id.toString();
            this.focusOption(prevIndex);
        }
        else if (e.key === 'Enter') {
            e.preventDefault();
            if (this.ariaActivedescendant) {
                const option = items[currentIndex];
                this.handleTimeChange(e, option.value);
                this.showTimes = false;
                this.ariaActivedescendant = '';
                this.timeInput.focus();
            }
        }
        else if (e.key === 'Escape') {
            this.showTimes = false;
            this.timeInput.focus();
        }
    }
    scrollToViewWithinParent(optionIndex) {
        const option = this.times[optionIndex];
        const childElement = this.el.shadowRoot?.getElementById(option.id.toString());
        const parentElement = this.timeMenu;
        this.ariaActivedescendant = option.id.toString();
        const childRect = childElement.getBoundingClientRect();
        const parentRect = parentElement.getBoundingClientRect();
        if (childRect.top < parentRect.top) {
            parentElement.scrollTop -= parentRect.top - childRect.top;
        }
        else if (childRect.bottom > parentRect.bottom) {
            parentElement.scrollTop += childRect.bottom - parentRect.bottom;
        }
        if (childRect.left < parentRect.left) {
            parentElement.scrollLeft -= parentRect.left - childRect.left;
        }
        else if (childRect.right > parentRect.right) {
            parentElement.scrollLeft += childRect.right - parentRect.right;
        }
    }
    focusOption(index) {
        const option = this.times[index];
        if (!option)
            return;
        const elementId = option.id.toString();
        const element = this.el.shadowRoot?.getElementById(elementId);
        if (element) {
            element.focus();
            element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }
    render() {
        return (index.h(index.Host, { key: '4a03bc9829bace5ed02129d99e12b6042f49386c' }, index.h("div", { key: 'ccc660e6cd8727226b7418ee20fe700812f7c70b', class: "time-picker", part: "time-picker" }, index.h("input", { key: '24be2b42322194545575045f5624ac78bf8c643e', type: "text", name: this.name, id: this.name, part: "time-input", class: {
                'time-input': true,
                'error': !!this.err || this.hasError,
            }, ref: el => (this.timeInput = el), value: this.time, onClick: () => {
                this.showTimes = true;
                this.shouldAutoScroll = true;
            }, "aria-haspopup": "listbox", "aria-label": this.name, "aria-expanded": this.showTimes ? 'true' : 'false', placeholder: this.placeholder, onKeyDown: e => this.handleComboboxKeyDown(e), onInput: event => this.handleOnInput(event), onBlur: event => this.handleTimeAutocomplete(event) }), this.err && index.h("div", { class: "invalid-time-icon" }), this.showTimes && (index.h("div", { class: "times", part: "times", ref: el => (this.timeMenu = el) }, index.h("ul", { tabindex: "-1", role: "listbox", "aria-label": this.name, "aria-activedescendant": this.ariaActivedescendant, onKeyDown: e => this.handleListboxKeydown(e) }, this.times.map(option => (index.h("li", { tabindex: "0", key: option.id, id: option.id.toString(), class: {
                focused: this.ariaActivedescendant === option.id.toString(),
            }, onClick: e => {
                this.handleTimeChange(e, option.value);
                this.showTimes = false;
                this.timeInput.focus();
            }, role: "option" }, `${option.value}`)))))), !this.showTimes && this.err && (index.h("p", { class: "error", id: "email-error" }, this.err)))));
    }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "minimumStartTime": ["minimumStartTimeChangedHandler"]
    }; }
};
TimeInput.style = nylasTimeWindowPickerCss;

exports.nylas_time_window_picker = TimeInput;

//# sourceMappingURL=nylas-time-window-picker.cjs.entry.js.map