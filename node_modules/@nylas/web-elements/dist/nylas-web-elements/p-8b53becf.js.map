{"version":3,"names":["createComponentEvent","instance","registeredComponent","eventName","CustomEvent","bubbles","composed","detail","unregisterComponentEvent","RegisterComponent","config","target","propKey","componentName","name","debug","origionalCallback","componentWillLoad","error","origionalConnectCallback","connectedCallback","origionalDisconnectCallback","disconnectedCallback","storeToProps","stateToProps","storeToPropsKeys","Array","from","values","stateToPropsKeys","intersection","filter","key","includes","length","join","eventToPropsMap","Map","eventToProps","Object","keys","forEach","set","origionalResult","call","this","host","getElement","dataset","nylasId","defineProperty","get","enumerable","getStoresToProp","authToProp","connectorToProp","localPropsToProp","fireRegisterEvent","element","event","registrationEventName","dispatchEvent","unregistrationEventName"],"sources":["src/common/register-component.ts"],"sourcesContent":["import { BaseNylasConnectorInterface } from '@/connector/connector-interface';\nimport { debug, error } from '@/utils/utils';\nimport { ComponentInterface, getElement } from '@stencil/core';\nimport { CombinedStoreStateKeys, EventEmitterEventType, ExtractEventEmitterKeys, ExtractEventEmitterProperties } from './types';\nexport interface RegisteredComponent<H extends ComponentInterface, B extends BaseNylasConnectorInterface, MailboxStores = string> {\n  name: string;\n  element: HTMLElement;\n  getStoresToProp?: keyof H;\n  storeToProps?: Map<string, keyof H>;\n  stateToProps?: Map<MailboxStores, keyof H>;\n  eventToProps?: Map<ExtractEventEmitterKeys<H>, (event: CustomEvent<EventEmitterEventType<H[ExtractEventEmitterKeys<H>]>>, nylasConnector: B) => Promise<void>>;\n  localPropsToProp?: Map<string, keyof H>;\n  authToProp?: keyof H;\n  connectorToProp?: keyof H;\n  registrationEventName?: string;\n  unregistrationEventName?: string;\n}\n\nexport function createComponentEvent<T extends ComponentInterface, B extends BaseNylasConnectorInterface>(\n  instance: T,\n  registeredComponent: RegisteredComponent<T, B>,\n  eventName: string = 'registerComponent',\n) {\n  return new CustomEvent<RegisteredComponent<typeof instance, B>>(eventName, {\n    bubbles: true,\n    composed: true,\n    detail: registeredComponent,\n  });\n}\n\nexport function unregisterComponentEvent<T extends ComponentInterface, B extends BaseNylasConnectorInterface>(\n  instance: T,\n  registeredComponent: RegisteredComponent<T, B>,\n  eventName: string = 'unregisterComponent',\n) {\n  return new CustomEvent<RegisteredComponent<typeof instance, B>>(eventName, {\n    bubbles: true,\n    composed: true,\n    detail: registeredComponent,\n  });\n}\n\nexport interface RegisterComponentConfig<H extends ComponentInterface, B extends BaseNylasConnectorInterface, MailboxStores>\n  extends Omit<RegisteredComponent<H, B, MailboxStores>, 'eventToProps' | 'name' | 'element'> {\n  name: string;\n  eventToProps?: Partial<{\n    [P in ExtractEventEmitterProperties<H> as P['key']]: (event: CustomEvent<P['eventType']>, nylasConnector: B) => Promise<void>;\n  }>;\n  fireRegisterEvent?: boolean;\n}\n\nexport interface NylasComponentInterface extends ComponentInterface {\n  authToProp?: keyof this;\n  connectorToProp?: keyof this;\n}\n\nexport function RegisterComponent<H extends NylasComponentInterface, B extends BaseNylasConnectorInterface, MailboxStores extends Record<string, any>>(\n  config: RegisterComponentConfig<H, B, CombinedStoreStateKeys<keyof MailboxStores, MailboxStores>>,\n) {\n  return (target: H, propKey: string) => {\n    const componentName = config.name;\n    debug(`[${componentName}] Registering component ${componentName} being called on ${propKey}`);\n\n    const origionalCallback = target.componentWillLoad;\n    if (!origionalCallback) {\n      error(`[${componentName}] componentWillLoad lifecycle method in ${componentName} missing. Required for RegisterComponent decorator.`);\n      return;\n    }\n\n    const origionalConnectCallback = target.connectedCallback;\n    if (!origionalConnectCallback) {\n      error(`[${componentName}] connectedCallback lifecycle method in ${componentName} missing. Required for RegisterComponent decorator.`);\n      return;\n    }\n\n    const origionalDisconnectCallback = target.disconnectedCallback;\n    if (!origionalDisconnectCallback) {\n      error(`[${componentName}] disconnectedCallback lifecycle method in ${componentName} missing. Required for RegisterComponent decorator.`);\n      return;\n    }\n\n    // Detect a conflict if config.storeToProps and config.stateToProps are both defined\n    // for overlapping prop keys\n    if (config.storeToProps && config.stateToProps) {\n      const storeToPropsKeys = Array.from(config.storeToProps.values());\n      const stateToPropsKeys = Array.from(config.stateToProps.values());\n      const intersection = storeToPropsKeys.filter(key => stateToPropsKeys.includes(key));\n      if (intersection.length > 0) {\n        error(\n          `[${componentName}] Overlapping prop keys detected in ${componentName} for storeToProps and stateToProps. Make sure to only define them once. Overlapping keys: ${intersection.join(\n            ', ',\n          )}`,\n        );\n        return;\n      }\n    }\n\n    // Convert the record of eventToProps to a map\n    const eventToPropsMap = new Map<ExtractEventEmitterKeys<H>, (event: CustomEvent<EventEmitterEventType<H[ExtractEventEmitterKeys<H>]>>, nylasConnector: B) => Promise<void>>();\n    if (config.eventToProps) {\n      Object.keys(config.eventToProps).forEach(key => {\n        eventToPropsMap.set(\n          key as ExtractEventEmitterKeys<H>,\n          config.eventToProps?.[key as ExtractEventEmitterKeys<H>] as (\n            event: CustomEvent<EventEmitterEventType<H[ExtractEventEmitterKeys<H>]>>,\n            nylasConnector: B,\n          ) => Promise<void>,\n        );\n      });\n    }\n\n    target.connectedCallback = function () {\n      debug(`[~${componentName}] connectedCallback called`);\n      const origionalResult = origionalConnectCallback?.call(this);\n      const host = getElement(this);\n\n      // If the nylas id is already set, then we don't need to do anything\n      if (host.dataset.nylasId) {\n        return origionalResult;\n      }\n\n      Object.defineProperty(host, 'registerNylasComponent', {\n        get() {\n          return true;\n        },\n        enumerable: true,\n      });\n      Object.defineProperty(host, 'stateToProps', {\n        get() {\n          return config.stateToProps;\n        },\n        enumerable: true,\n      });\n      Object.defineProperty(host, 'getStoresToProp', {\n        get() {\n          return config.getStoresToProp;\n        },\n        enumerable: true,\n      });\n      Object.defineProperty(host, 'storeToProps', {\n        get() {\n          return config.storeToProps;\n        },\n        enumerable: true,\n      });\n      Object.defineProperty(host, 'eventToProps', {\n        get() {\n          return eventToPropsMap;\n        },\n        enumerable: true,\n      });\n      Object.defineProperty(host, 'authToProp', {\n        get() {\n          return config.authToProp;\n        },\n        enumerable: true,\n      });\n      Object.defineProperty(host, 'connectorToProp', {\n        get() {\n          return config.connectorToProp;\n        },\n        enumerable: true,\n      });\n      Object.defineProperty(host, 'localPropsToProp', {\n        get() {\n          return config.localPropsToProp;\n        },\n        enumerable: true,\n      });\n      return origionalResult;\n    };\n\n    if (config.fireRegisterEvent) {\n      target.componentWillLoad = function () {\n        const origionalResult = origionalCallback?.call(this);\n        const host = getElement(this);\n\n        // We use our host element to dispatch a registration event that is picked up by the\n        // the nylas-provider component.\n        const registeredComponent: RegisteredComponent<H, B> = {\n          element: host,\n          ...config,\n          eventToProps: eventToPropsMap,\n        };\n        const event = createComponentEvent(target, registeredComponent, config.registrationEventName);\n        if (host.dispatchEvent(event)) {\n          debug(`[${componentName}] Component ${componentName} successfully fired registration event`);\n        }\n\n        return origionalResult;\n      };\n\n      target.disconnectedCallback = function () {\n        const origionalResult = origionalDisconnectCallback?.call(this);\n        const host = getElement(this);\n\n        // We use our host element to dispatch a registration event that is picked up by the\n        // the nylas-provider component.\n        const registeredComponent: RegisteredComponent<H, B> = {\n          element: host,\n          ...config,\n          eventToProps: eventToPropsMap,\n        };\n        const event = unregisterComponentEvent(target, registeredComponent, config.unregistrationEventName);\n        if (host.dispatchEvent(event)) {\n          debug(`[${componentName}] Component ${componentName} successfully fired unregistration event`);\n        }\n\n        return origionalResult;\n      };\n    }\n  };\n}\n"],"mappings":"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"}