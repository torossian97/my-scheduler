{"version":3,"names":["NylasAuthConnector","constructor","nylasAuth","nylasAuthStore","this","validateSession","isAuthenticated","isAccessTokenValid","logout","tokenInfo","getTokenInfo","expireTimeCheck","currentTimeInSeconds","Math","floor","Date","now","expires_in","debug","refreshAccessToken","state","getHostedAuthRedirectURL","scopes","email","provider","manageHostedAuthCodeExchange","currentUrl","url","URL","code","searchParams","get","exchangeAuthCodeForTokenInfo","NylasMessagesConnector","nylasMailboxStore","getMessages","Error","hasScopeByType","queryParams","messgeQueryParams","params","URLSearchParams","key","value","toString","append","path","response","nylasAPIRequest","isNylasErrorResponse","NylasAPIError","error","messages","data","getThreadMessages","threadId","downloadMessageAttachments","message","blobPromises","attachments","attachment","blob","nylasDownloadFileRequest","id","push","summarizeText","text","body","config","elementsApiUri","summary","textToSpeech","abortController","signal","NylasThreadsConnector","router","getThreads","overrideQueryParams","updateMethod","updateState","threadsQueryParams","search_query_native","navigate","page_token","previousThreadPageTokens","threads","next_cursor","nextThreadPageToken","getThread","storeThread","find","t","thread","map","nextThreadPage","updateLoadingState","Array","from","Set","nextPageToken","previousThreadPage","aupdateMethod","length","pageToken","pop","undefined","updateThreadQueryParams","back","selectedThread","unSelectThread","selectThread","unread","markThreadAsRead","catch","updateThread","updatedThread","NylasFoldersConnector","getFolders","folders","selectFolder","folder","in","PolyFillHashChangeEvent","Event","type","eventInitDict","super","oldURL","newURL","HashRouter","routeChangeListeners","destroy","window","removeEventListener","onRouteChange","bind","init","addEventListener","HashChangeEvent","event","location","href","addRouteChangeListener","route","listener","shallow","history","pushState","hash","setRoute","matchRoute","routeParts","split","pathParts","i","routePart","pathPart","startsWith","getRouteParams","routeParams","routeConfigParts","forEach","index","substring","getRouteWithParams","routeWithParams","Object","keys","replace","getRoute","async","indexOf","getBasePath","CreateNylasAuthStore","defaultState","defaultNylasStoreState","store","createStore","reset","set","CreateNylasMailboxStore","searchQuery","hasNextThreadPage","hasPreviousThreadPage","selectedFolder","fields","onChange"],"sources":["src/connector/shared/api/auth.ts","src/connector/shared/api/messages.ts","src/connector/shared/api/threads.ts","src/connector/shared/api/folders.ts","src/routers/hash-router.ts","src/stores/auth-store.ts","src/stores/mailbox-store.ts"],"sourcesContent":["import { debug } from '@/utils/utils';\nimport { NylasAuthStoreType, NylasAuthType, TokenInfo } from '../../..';\n\nexport class NylasAuthConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n  }\n\n  /**\n   * Validates the current session and updates the store with the token info\n   * if the user is authenticated.\n   * If the user is not authenticated, the store is reset.\n   * @returns {Promise<void>}\n   */\n  public async validateSession(): Promise<void> {\n    const isAuthenticated = await this.isAccessTokenValid();\n    if (!isAuthenticated) {\n      // Reset the store if the access token is not valid\n      this.logout();\n    } else {\n      // If the user is authenticated, update the store with the token info\n      let tokenInfo = await this.nylasAuth.getTokenInfo();\n      if (tokenInfo) {\n        // If token is expired or about to expire (in 5 minutes), refresh it\n        const expireTimeCheck = 5 * 60 * 1000; // 5 minutes\n        const currentTimeInSeconds = Math.floor(Date.now() / 1000);\n\n        if (tokenInfo.expires_in && tokenInfo.expires_in - currentTimeInSeconds < expireTimeCheck) {\n          debug('[NylasAuthConnectorMixin] Refreshing access token');\n          tokenInfo = await this.nylasAuth.refreshAccessToken();\n          if (!tokenInfo) {\n            debug('[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out.');\n            this.logout();\n            return;\n          }\n        }\n\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n      }\n    }\n    this.nylasAuthStore.state.isAuthenticated = isAuthenticated;\n  }\n\n  /**\n   * Returns true if the user is authenticated.\n   * @returns {Promise<boolean>}\n   */\n  public async isAuthenticated(): Promise<boolean> {\n    return this.nylasAuth.isAuthenticated();\n  }\n\n  /**\n   * Returns the token info if the user is authenticated.\n   * @returns {Promise<TokenInfo>}\n   */\n  public async getTokenInfo(): Promise<TokenInfo | null> {\n    return this.nylasAuth.getTokenInfo();\n  }\n\n  /**\n   * Returns true if the access token is valid.\n   * @returns {Promise<boolean>}\n   */\n  public async isAccessTokenValid(): Promise<boolean> {\n    return this.nylasAuth.isAccessTokenValid();\n  }\n\n  /**\n   * Removes the token info from the store and logs the user out.\n   * @returns {Promise<void>}\n   */\n  public async logout(): Promise<void> {\n    await this.nylasAuth.logout();\n  }\n\n  /**\n   * Returns the URL to redirect the user to for authentication.\n   * @param scopes An array of scopes to request from the user.\n   * @param email The email address of the user to authenticate.\n   * @param provider The provider to use for authentication.\n   * @returns {Promise<string>}\n   */\n  public async getHostedAuthRedirectURL(scopes?: string[], email?: string, provider?: string): Promise<string> {\n    return this.nylasAuth.getHostedAuthRedirectURL(scopes, email, provider);\n  }\n\n  /**\n   * Exchanges the auth code for a token info and updates the store.\n   * @param currentUrl The current URL of the page.\n   * @returns {Promise<TokenInfo | null>}\n   */\n  public async manageHostedAuthCodeExchange(currentUrl: string): Promise<TokenInfo | null> {\n    const url = new URL(currentUrl);\n    const code = url.searchParams.get('code');\n\n    if (code) {\n      const tokenInfo = await this.nylasAuth.exchangeAuthCodeForTokenInfo(code);\n      if (tokenInfo) {\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n        this.nylasAuthStore.state.isAuthenticated = true;\n        return tokenInfo;\n      }\n    }\n\n    return null;\n  }\n}\n","import { Message, NylasAPIError, NylasAuthType, NylasResponse, isNylasErrorResponse } from '@nylas/core';\nimport { NylasAuthStoreType, NylasMailboxStoreType } from '../../../components';\n\nexport class NylasMessagesConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n  private nylasMailboxStore: NylasMailboxStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasMailboxStore: NylasMailboxStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasMailboxStore = nylasMailboxStore;\n  }\n\n  /**\n   * Returns the list of messages.\n   * @returns {Promise<Message[]>}\n   */\n  public async getMessages(): Promise<Message[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    // Set the state to loading.\n    this.nylasMailboxStore.state.state = 'loading';\n\n    // Get the message query parameters from the store.\n    const queryParams = this.nylasMailboxStore.state.messgeQueryParams;\n\n    // Build the URLSearchParams object.\n    const params = new URLSearchParams();\n    for (const key in queryParams) {\n      const value = queryParams[key as keyof typeof queryParams]?.toString();\n      if (value) {\n        params.append(key, value);\n      }\n    }\n\n    // Build the URL with the query parameters\n    const path = `/v3/grants/me/messages?${params.toString()}`;\n\n    // Make the API request.\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Message[]>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the messages in the store.\n    const messages = response.data;\n    this.nylasMailboxStore.state.messages = messages;\n\n    // Set the state to ready.\n    this.nylasMailboxStore.state.state = 'ready';\n\n    return messages;\n  }\n\n  /**\n   * Returns the list of messages for a given thread.\n   * @param {string} threadId The thread ID.\n   * @returns {Promise<Message[]>}\n   * @throws {NylasAPIError}\n   */\n  public async getThreadMessages(threadId: string): Promise<Message[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Message[]>>(`/v3/grants/me/messages?thread_id=${threadId}&fields=include_headers`);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    const messages = response.data;\n    this.nylasMailboxStore.state.messages = messages;\n\n    return messages;\n  }\n\n  /**\n   * Downloads the attachments for a given message.\n   * @param message The message to download attachments for.\n   * @returns {Promise<Blob>[]} An array of promises that will resolve to a Blob.\n   */\n  public downloadMessageAttachments(message: Message): Promise<Blob>[] {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    // We'll go through each attachment and download it.\n    const blobPromises: Promise<Blob>[] = [];\n    const attachments = message.attachments || [];\n    for (const attachment of attachments) {\n      const blob = this.nylasAuth.nylasDownloadFileRequest(`/v3/grants/me/attachments/${attachment.id}?message_id=${message.id}`);\n      blobPromises.push(blob);\n    }\n\n    return blobPromises;\n  }\n\n  /**\n   * Returns a summarized version of the given text.\n   * @param text The non-HTML text to summarize.\n   * @returns {Promise<string>} The summarized text.\n   */\n  public async summarizeText(text: string): Promise<string> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<{ summary: string }>>(\n      `/v3/grants/me/mailbox/summarize`,\n      'POST',\n      {\n        message: {\n          body: text,\n        },\n      },\n      true,\n      this.nylasAuth.config.elementsApiUri,\n    );\n\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    return response.data.summary;\n  }\n\n  /**\n   * Returns a summarized version of the given message.\n   * @param message The message to summarize.\n   * @returns {Promise<ReadableStream<Uint8Array> | null>} Returns a Fetch API response.\n   */\n  public async textToSpeech(text: string, abortController?: AbortController): Promise<ReadableStream<Uint8Array> | null> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    return this.nylasAuth.nylasAPIRequest(\n      `/v3/grants/me/mailbox/tts`,\n      'POST',\n      {\n        text,\n      },\n      false,\n      this.nylasAuth.config.elementsApiUri,\n      {\n        ...(abortController ? { signal: abortController?.signal } : {}),\n      },\n    );\n  }\n}\n","import { debug } from '@/utils/utils';\nimport { NylasAPIError, NylasAuthType, NylasResponse, Thread, ThreadQueryParameters, isNylasErrorResponse } from '@nylas/core';\nimport { NylasAuthStoreType, NylasMailboxStoreType } from '../../../components';\nimport { RouterInterface } from '@/routers/router-interface';\n\nexport class NylasThreadsConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n  private nylasMailboxStore: NylasMailboxStoreType;\n  private router: RouterInterface;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasMailboxStore: NylasMailboxStoreType, router: RouterInterface) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasMailboxStore = nylasMailboxStore;\n    this.router = router;\n  }\n\n  /**\n   * Returns the list of threads.\n   * @todo Re-think how we handle pagination (previous/next page tokens) - there is a separation of logic here that might be confusing.\n   * @param {Partial<ThreadQueryParameters> | undefined} overrideQueryParams The query parameters to override from the store.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateState Whether to update the state or not (default: true).\n   * @returns {Promise<Thread[]>}\n   */\n  public async getThreads(\n    overrideQueryParams?: Partial<ThreadQueryParameters>,\n    updateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite',\n    updateState: boolean = true,\n  ): Promise<Thread[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Set the state to loading.\n    if (updateState) {\n      this.nylasMailboxStore.state.state = 'loading';\n    }\n\n    // Build the URL with the query parameters\n    const queryParams = overrideQueryParams || this.nylasMailboxStore.state.threadsQueryParams;\n    const params = new URLSearchParams();\n    for (const key in queryParams) {\n      const value = queryParams[key as keyof typeof queryParams]?.toString();\n      if (typeof value !== 'undefined' && value !== null) {\n        params.append(key, value);\n      }\n    }\n\n    // TODO: Re-think how to update the router, this seems wrong\n    if (queryParams.search_query_native) {\n      this.router.navigate(`/?query=${queryParams.search_query_native}`, true);\n    } else if (this.nylasMailboxStore.state.threadsQueryParams.search_query_native && !queryParams.search_query_native) {\n      this.router.navigate('/', true);\n    }\n\n    // If page_token is not set, reset the previous page tokens.\n    if (!queryParams.page_token) {\n      this.nylasMailboxStore.state.previousThreadPageTokens = [];\n    }\n\n    this.nylasMailboxStore.state.threadsQueryParams = queryParams;\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads?${params.toString()}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread[]>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const threads = response.data;\n    switch (updateMethod) {\n      case 'prepend':\n        this.nylasMailboxStore.state.threads = [...threads, ...this.nylasMailboxStore.state.threads];\n        break;\n      case 'append':\n        this.nylasMailboxStore.state.threads = [...this.nylasMailboxStore.state.threads, ...threads];\n        break;\n      case 'overwrite':\n      default:\n        this.nylasMailboxStore.state.threads = threads;\n        break;\n    }\n\n    // If we have a next cursor, set it in the store.\n    if (response.next_cursor) {\n      this.nylasMailboxStore.state.nextThreadPageToken = response.next_cursor;\n    } else {\n      this.nylasMailboxStore.state.nextThreadPageToken = null;\n    }\n\n    // Set the state to ready.\n    if (updateState) {\n      this.nylasMailboxStore.state.state = 'ready';\n    }\n\n    return threads;\n  }\n\n  public async getThread(threadId: string): Promise<Thread> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Check if we have the thread in the store already.\n    const storeThread = this.nylasMailboxStore.state.threads.find(t => t.id === threadId);\n    if (storeThread) {\n      return storeThread;\n    }\n\n    // Set the state to loading.\n    this.nylasMailboxStore.state.state = 'loading';\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads/${threadId}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const thread = response.data;\n    this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {\n      if (t.id === thread.id) {\n        return thread;\n      }\n      return t;\n    });\n\n    // Set the state to ready.\n    this.nylasMailboxStore.state.state = 'ready';\n\n    return thread;\n  }\n\n  /**\n   * Returns the next page of threads.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateLoadingState Whether to update the loading state or not.\n   * @returns {Promise<Thread[]>} The previous page of threads.\n   */\n  public async nextThreadPage(updateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite', updateLoadingState: boolean = true): Promise<Thread[]> {\n    if (!this.nylasMailboxStore.state.nextThreadPageToken) {\n      throw new Error('No next page token');\n    }\n\n    // If we have a next page token, add it to the previous page tokens.\n    this.nylasMailboxStore.state.previousThreadPageTokens = Array.from(\n      new Set([...this.nylasMailboxStore.state.previousThreadPageTokens, this.nylasMailboxStore.state.threadsQueryParams.page_token ?? null]),\n    );\n\n    // Get the last next page token.\n    const nextPageToken = this.nylasMailboxStore.state.nextThreadPageToken;\n\n    return this.getThreads(\n      {\n        ...this.nylasMailboxStore.state.threadsQueryParams,\n        page_token: nextPageToken,\n      },\n      updateMethod,\n      updateLoadingState,\n    );\n  }\n\n  /**\n   * Returns the previous page of threads.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateLoadingState Whether to update the loading state or not.\n   * @returns {Promise<Thread[]>} The previous page of threads.\n   */\n  public async previousThreadPage(aupdateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite', updateLoadingState: boolean = true): Promise<Thread[]> {\n    if (!this.nylasMailboxStore.state.previousThreadPageTokens.length) {\n      throw new Error('No previous page token');\n    }\n\n    // Remove the the last two next page tokens.\n    const previousThreadPageTokens = [...this.nylasMailboxStore.state.previousThreadPageTokens];\n    const pageToken = previousThreadPageTokens.pop();\n\n    // Update the store.\n    this.nylasMailboxStore.state.previousThreadPageTokens = previousThreadPageTokens;\n\n    return this.getThreads(\n      {\n        ...this.nylasMailboxStore.state.threadsQueryParams,\n        page_token: pageToken ?? undefined,\n      },\n      aupdateMethod,\n      updateLoadingState,\n    );\n  }\n\n  /**\n   * Updates the thread query parameters in the store.\n   * @param params Partial<ThreadQueryParameters>\n   * @returns {void}\n   */\n  public updateThreadQueryParams(params: Partial<ThreadQueryParameters>): void {\n    this.nylasMailboxStore.state.threadsQueryParams = {\n      ...this.nylasMailboxStore.state.threadsQueryParams,\n      ...params,\n    };\n  }\n\n  /**\n   * Back to the mailbox.\n   */\n  public back(): void {\n    this.router.navigate('/', true);\n    this.nylasMailboxStore.state.selectedThread = null;\n  }\n\n  /**\n   * Unselects a thread.\n   */\n  public unSelectThread(): void {\n    this.nylasMailboxStore.state.selectedThread = null;\n  }\n\n  /**\n   * Selects a thread.\n   * @param {Thread} thread The thread to select.\n   * @returns {Promise<void>}\n   */\n  public async selectThread(thread: Thread): Promise<void> {\n    this.router.navigate(`/thread/${thread.id}`, true);\n    this.nylasMailboxStore.state.selectedThread = thread;\n\n    // Mark the thread as read (async) if it is unread.\n    if (thread.unread) {\n      this.markThreadAsRead(thread).catch(error => {\n        debug('Error marking thread as read', error);\n      });\n    }\n  }\n\n  /**\n   * Marks a thread as read.\n   * @param thread\n   * @returns {Promise<Thread>}\n   */\n  public async markThreadAsRead(thread: Thread): Promise<Thread> {\n    return this.updateThread(thread, { unread: false });\n  }\n\n  /**\n   * Updates a thread.\n   * @param thread The thread to update.\n   * @returns {Promise<Thread>}\n   */\n  public async updateThread(thread: Thread, updateThread: Partial<Thread>): Promise<Thread> {\n    // Make sure we have an authenticated user.\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a modify scope at least.\n    if (!this.nylasAuth.hasScopeByType('email', 'modify')) {\n      throw new Error('Missing thread:modify scope');\n    }\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads/${thread.id}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread>>(path, 'PUT', updateThread);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Update the thread in the store.\n    const updatedThread = response.data;\n    this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {\n      if (t.id === updatedThread.id) {\n        return updatedThread;\n      }\n      return t;\n    });\n    this.nylasMailboxStore.state.selectedThread = updatedThread;\n\n    return updatedThread;\n  }\n}\n","import { Folder, NylasAPIError, NylasAuthType, NylasResponse, isNylasErrorResponse } from '@nylas/core';\nimport { NylasAuthStoreType, NylasMailboxStoreType } from '../../../components';\n\nexport class NylasFoldersConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n  private nylasMailboxStore: NylasMailboxStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasMailboxStore: NylasMailboxStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasMailboxStore = nylasMailboxStore;\n  }\n\n  /**\n   * Returns the list of folders.\n   */\n  public async getFolders(): Promise<Folder[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Set the state to loading.\n    this.nylasMailboxStore.state.state = 'loading';\n\n    // Make the API request.\n    const path = `/v3/grants/me/folders`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Folder[]>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const folders = response.data;\n    this.nylasMailboxStore.state.folders = folders;\n\n    // Set the state to ready.\n    this.nylasMailboxStore.state.state = 'ready';\n\n    return folders;\n  }\n\n  public async selectFolder(folder: Folder) {\n    this.nylasMailboxStore.state.threadsQueryParams = {\n      in: folder.id,\n      ...(this.nylasMailboxStore.state.threadsQueryParams || {}),\n    };\n  }\n}\n","import { debug } from '@/utils/utils';\nimport { RouteListener, RouteParams, RoutePath, RouterInterface } from './router-interface';\n\nexport class PolyFillHashChangeEvent extends Event {\n  oldURL?: string;\n  newURL?: string;\n\n  constructor(type: string, eventInitDict: HashChangeEventInit) {\n    super(type, eventInitDict);\n    this.oldURL = eventInitDict.oldURL;\n    this.newURL = eventInitDict.newURL;\n  }\n}\n\nexport class HashRouter implements RouterInterface {\n  private routeChangeListeners: [route: RoutePath, RouteListener<any>][] = [];\n\n  constructor() {\n    debug('HashRouter constructor');\n  }\n\n  // Destroy the router\n  public destroy(): void {\n    debug('HashRouter destroy');\n    window.removeEventListener('hashchange', this.onRouteChange.bind(this));\n  }\n\n  // Initialize the router\n  public init(): void {\n    debug('HashRouter init');\n    window.addEventListener('hashchange', this.onRouteChange.bind(this));\n\n    // Trigger the initial route change\n    if (typeof HashChangeEvent !== 'undefined') {\n      const event: HashChangeEvent = new HashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event);\n    } else {\n      const event: Event = new PolyFillHashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event as HashChangeEvent);\n    }\n  }\n\n  public addRouteChangeListener<Path extends RoutePath>(route: Path, listener: RouteListener<Path>): void {\n    debug('HashRouter addRouteChangeListener');\n    this.routeChangeListeners.push([route, listener]);\n  }\n\n  public navigate(route: string, shallow: boolean): void {\n    debug('HashRouter navigate');\n\n    // If we're navigating shallow, don't add a new history entry\n    if (shallow) {\n      return window.history.pushState(null, '', `#${route}`);\n    }\n\n    window.location.hash = route;\n  }\n\n  public setRoute(route: string): void {\n    debug('HashRouter setRoute');\n    window.location.hash = route;\n  }\n\n  // Matches a route and executes the callback\n  public matchRoute(route: string, path: string): boolean {\n    const routeParts = route.split('/');\n    const pathParts = path.split('/');\n\n    // If the route is `/` an the hash is empty, match the route\n    debug(`HashRouter matchRoute route=${route} path=${path}`, { routeParts, pathParts });\n    if (routeParts[1] === '' && pathParts[0] === '') {\n      return true;\n    }\n\n    if (routeParts.length !== pathParts.length) {\n      return false;\n    }\n\n    for (let i = 0; i < routeParts.length; i++) {\n      const routePart = routeParts[i];\n      const pathPart = pathParts[i];\n      if (routePart.startsWith(':')) {\n        continue;\n      }\n      if (routePart !== pathPart) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Parse the route and return the route params\n  public getRouteParams<Path extends RoutePath>(route: Path): RouteParams<Path> {\n    debug('HashRouter getRouteParams');\n    const routeParams: RouteParams<Path> = {} as RouteParams<Path>;\n    const routeParts = route.split('/');\n    const routeConfigParts = window.location.hash.split('/');\n    routeParts.forEach((routePart, index) => {\n      if (routePart.startsWith(':')) {\n        const key = routePart.substring(1) as keyof RouteParams<Path>;\n        routeParams[key] = routeConfigParts[index] as RouteParams<Path>[keyof RouteParams<Path>]; // Cast the value to string\n      }\n    });\n    return routeParams;\n  }\n\n  public getRouteWithParams(route: string, routeParams: Record<string, any>): string {\n    debug('HashRouter getRouteWithParams');\n    let routeWithParams = route;\n    Object.keys(routeParams).forEach(key => {\n      routeWithParams = routeWithParams.replace(`:${key}`, routeParams[key]);\n    });\n    return routeWithParams;\n  }\n\n  public getRoute(): string {\n    debug('HashRouter getRoute');\n    return window.location.hash;\n  }\n\n  public onRouteChange(event: HashChangeEvent): void {\n    this.routeChangeListeners.forEach(async ([route, listener]) => {\n      const path = event.newURL.indexOf('#') === -1 ? '' : event.newURL.substring(event.newURL.indexOf('#') + 1);\n      debug(`HashRouter onRouteChange route=${route} path=${path}`, { event });\n      if (!this.matchRoute(route, path)) {\n        debug(`HashRouter onRouteChange route=${route} path=${path} does not match`);\n        return;\n      }\n      const routeParams = this.getRouteParams(route) as RouteParams<RoutePath>;\n      await listener(route, path, routeParams);\n    });\n  }\n\n  public getBasePath(): string {\n    debug('HashRouter getBasePath');\n    return '';\n  }\n}\n","import { TokenInfo } from '@nylas/core/dist/auth';\nimport { createStore } from '@stencil/store';\nimport { DataState } from '..';\n\nexport interface NylasAuthStoreState {\n  isAuthenticated: boolean;\n  tokenInfo: TokenInfo | null;\n  state: DataState;\n}\n\nexport type NylasAuthStoreType = ReturnType<typeof CreateNylasAuthStore>;\n\nexport function CreateNylasAuthStore(defaultState: Partial<NylasAuthStoreState> = {}) {\n  const defaultNylasStoreState: NylasAuthStoreState = {\n    isAuthenticated: false,\n    tokenInfo: null,\n    state: 'ready',\n    ...defaultState,\n  };\n  const store = createStore<NylasAuthStoreState>(defaultNylasStoreState);\n\n  /**\n   * Reset the Nylas store to its default state.\n   * There is something wrong with the stencil/store reset method,\n   * so we have to do it via this hack.\n   */\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n","import type { Folder, Message, MessageQueryParameters, Thread, ThreadQueryParameters } from '@nylas/core';\nimport { createStore } from '@stencil/store';\nimport { DataState } from '../components';\n\nexport interface NylasMailboxStoreState {\n  state: DataState;\n  messages: Message[];\n  threads: Thread[];\n  folders: Folder[];\n  selectedThread: Thread | null;\n  selectedFolder: string;\n  searchQuery: string;\n\n  nextThreadPageToken: string | null;\n  previousThreadPageTokens: (string | null)[];\n  hasNextThreadPage: boolean;\n  hasPreviousThreadPage: boolean;\n  threadsQueryParams: Partial<ThreadQueryParameters>;\n  messgeQueryParams: Partial<MessageQueryParameters>;\n}\n\nexport type NylasMailboxStoreType = ReturnType<typeof CreateNylasMailboxStore>;\n\nexport function CreateNylasMailboxStore(defaultState: Partial<NylasMailboxStoreState> = {}) {\n  const defaultNylasStoreState: NylasMailboxStoreState = {\n    state: 'ready',\n\n    messages: [],\n    threads: [],\n    folders: [],\n    selectedThread: null,\n    nextThreadPageToken: null,\n    previousThreadPageTokens: [],\n    searchQuery: '',\n\n    hasNextThreadPage: false,\n    hasPreviousThreadPage: false,\n\n    selectedFolder: 'inbox',\n\n    threadsQueryParams: {\n      in: 'inbox',\n    },\n    messgeQueryParams: {\n      fields: 'include_headers',\n    },\n    ...defaultState,\n  };\n\n  const store = createStore<NylasMailboxStoreState>({ ...defaultNylasStoreState });\n\n  // Set our hasNextThreadPage if nextThreadPageToken is not null.\n  store.onChange('nextThreadPageToken', nextThreadPageToken => {\n    store.set('hasNextThreadPage', nextThreadPageToken !== null);\n  });\n  // Set our hasPreviousThreadPage if previousThreadPageTokens is not empty.\n  store.onChange('previousThreadPageTokens', previousThreadPageTokens => {\n    store.set('hasPreviousThreadPage', previousThreadPageTokens.length > 0);\n  });\n\n  // When threadsQueryParams changes...\n  store.onChange('threadsQueryParams', threadsQueryParams => {\n    // set our selectedFolder to the in param.\n    store.set('selectedFolder', threadsQueryParams.in || 'inbox');\n    // set our searchQuery to the search_query_native param.\n    store.set('searchQuery', threadsQueryParams.search_query_native || '');\n  });\n\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n"],"mappings":"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"}