{"file":"mailbox-store-9f819402.js","mappings":"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","names":["isNylasErrorResponse","NylasAPIError"],"sources":["src/connector/shared/api/auth.ts","src/connector/shared/api/messages.ts","src/connector/shared/api/threads.ts","src/connector/shared/api/folders.ts","src/routers/hash-router.ts","src/stores/auth-store.ts","src/stores/mailbox-store.ts"],"sourcesContent":["import { debug } from '@/utils/utils';\nimport { NylasAuthStoreType, NylasAuthType, TokenInfo } from '../../..';\n\nexport class NylasAuthConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n  }\n\n  /**\n   * Validates the current session and updates the store with the token info\n   * if the user is authenticated.\n   * If the user is not authenticated, the store is reset.\n   * @returns {Promise<void>}\n   */\n  public async validateSession(): Promise<void> {\n    const isAuthenticated = await this.isAccessTokenValid();\n    if (!isAuthenticated) {\n      // Reset the store if the access token is not valid\n      this.logout();\n    } else {\n      // If the user is authenticated, update the store with the token info\n      let tokenInfo = await this.nylasAuth.getTokenInfo();\n      if (tokenInfo) {\n        // If token is expired or about to expire (in 5 minutes), refresh it\n        const expireTimeCheck = 5 * 60 * 1000; // 5 minutes\n        const currentTimeInSeconds = Math.floor(Date.now() / 1000);\n\n        if (tokenInfo.expires_in && tokenInfo.expires_in - currentTimeInSeconds < expireTimeCheck) {\n          debug('[NylasAuthConnectorMixin] Refreshing access token');\n          tokenInfo = await this.nylasAuth.refreshAccessToken();\n          if (!tokenInfo) {\n            debug('[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out.');\n            this.logout();\n            return;\n          }\n        }\n\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n      }\n    }\n    this.nylasAuthStore.state.isAuthenticated = isAuthenticated;\n  }\n\n  /**\n   * Returns true if the user is authenticated.\n   * @returns {Promise<boolean>}\n   */\n  public async isAuthenticated(): Promise<boolean> {\n    return this.nylasAuth.isAuthenticated();\n  }\n\n  /**\n   * Returns the token info if the user is authenticated.\n   * @returns {Promise<TokenInfo>}\n   */\n  public async getTokenInfo(): Promise<TokenInfo | null> {\n    return this.nylasAuth.getTokenInfo();\n  }\n\n  /**\n   * Returns true if the access token is valid.\n   * @returns {Promise<boolean>}\n   */\n  public async isAccessTokenValid(): Promise<boolean> {\n    return this.nylasAuth.isAccessTokenValid();\n  }\n\n  /**\n   * Removes the token info from the store and logs the user out.\n   * @returns {Promise<void>}\n   */\n  public async logout(): Promise<void> {\n    await this.nylasAuth.logout();\n  }\n\n  /**\n   * Returns the URL to redirect the user to for authentication.\n   * @param scopes An array of scopes to request from the user.\n   * @param email The email address of the user to authenticate.\n   * @param provider The provider to use for authentication.\n   * @returns {Promise<string>}\n   */\n  public async getHostedAuthRedirectURL(scopes?: string[], email?: string, provider?: string): Promise<string> {\n    return this.nylasAuth.getHostedAuthRedirectURL(scopes, email, provider);\n  }\n\n  /**\n   * Exchanges the auth code for a token info and updates the store.\n   * @param currentUrl The current URL of the page.\n   * @returns {Promise<TokenInfo | null>}\n   */\n  public async manageHostedAuthCodeExchange(currentUrl: string): Promise<TokenInfo | null> {\n    const url = new URL(currentUrl);\n    const code = url.searchParams.get('code');\n\n    if (code) {\n      const tokenInfo = await this.nylasAuth.exchangeAuthCodeForTokenInfo(code);\n      if (tokenInfo) {\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n        this.nylasAuthStore.state.isAuthenticated = true;\n        return tokenInfo;\n      }\n    }\n\n    return null;\n  }\n}\n","import { Message, NylasAPIError, NylasAuthType, NylasResponse, isNylasErrorResponse } from '@nylas/core';\nimport { NylasAuthStoreType, NylasMailboxStoreType } from '../../../components';\n\nexport class NylasMessagesConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n  private nylasMailboxStore: NylasMailboxStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasMailboxStore: NylasMailboxStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasMailboxStore = nylasMailboxStore;\n  }\n\n  /**\n   * Returns the list of messages.\n   * @returns {Promise<Message[]>}\n   */\n  public async getMessages(): Promise<Message[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    // Set the state to loading.\n    this.nylasMailboxStore.state.state = 'loading';\n\n    // Get the message query parameters from the store.\n    const queryParams = this.nylasMailboxStore.state.messgeQueryParams;\n\n    // Build the URLSearchParams object.\n    const params = new URLSearchParams();\n    for (const key in queryParams) {\n      const value = queryParams[key as keyof typeof queryParams]?.toString();\n      if (value) {\n        params.append(key, value);\n      }\n    }\n\n    // Build the URL with the query parameters\n    const path = `/v3/grants/me/messages?${params.toString()}`;\n\n    // Make the API request.\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Message[]>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the messages in the store.\n    const messages = response.data;\n    this.nylasMailboxStore.state.messages = messages;\n\n    // Set the state to ready.\n    this.nylasMailboxStore.state.state = 'ready';\n\n    return messages;\n  }\n\n  /**\n   * Returns the list of messages for a given thread.\n   * @param {string} threadId The thread ID.\n   * @returns {Promise<Message[]>}\n   * @throws {NylasAPIError}\n   */\n  public async getThreadMessages(threadId: string): Promise<Message[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Message[]>>(`/v3/grants/me/messages?thread_id=${threadId}&fields=include_headers`);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    const messages = response.data;\n    this.nylasMailboxStore.state.messages = messages;\n\n    return messages;\n  }\n\n  /**\n   * Downloads the attachments for a given message.\n   * @param message The message to download attachments for.\n   * @returns {Promise<Blob>[]} An array of promises that will resolve to a Blob.\n   */\n  public downloadMessageAttachments(message: Message): Promise<Blob>[] {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    // We'll go through each attachment and download it.\n    const blobPromises: Promise<Blob>[] = [];\n    const attachments = message.attachments || [];\n    for (const attachment of attachments) {\n      const blob = this.nylasAuth.nylasDownloadFileRequest(`/v3/grants/me/attachments/${attachment.id}?message_id=${message.id}`);\n      blobPromises.push(blob);\n    }\n\n    return blobPromises;\n  }\n\n  /**\n   * Returns a summarized version of the given text.\n   * @param text The non-HTML text to summarize.\n   * @returns {Promise<string>} The summarized text.\n   */\n  public async summarizeText(text: string): Promise<string> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<{ summary: string }>>(\n      `/v3/grants/me/mailbox/summarize`,\n      'POST',\n      {\n        message: {\n          body: text,\n        },\n      },\n      true,\n      this.nylasAuth.config.elementsApiUri,\n    );\n\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    return response.data.summary;\n  }\n\n  /**\n   * Returns a summarized version of the given message.\n   * @param message The message to summarize.\n   * @returns {Promise<ReadableStream<Uint8Array> | null>} Returns a Fetch API response.\n   */\n  public async textToSpeech(text: string, abortController?: AbortController): Promise<ReadableStream<Uint8Array> | null> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing message:read-only scope');\n    }\n\n    return this.nylasAuth.nylasAPIRequest(\n      `/v3/grants/me/mailbox/tts`,\n      'POST',\n      {\n        text,\n      },\n      false,\n      this.nylasAuth.config.elementsApiUri,\n      {\n        ...(abortController ? { signal: abortController?.signal } : {}),\n      },\n    );\n  }\n}\n","import { debug } from '@/utils/utils';\nimport { NylasAPIError, NylasAuthType, NylasResponse, Thread, ThreadQueryParameters, isNylasErrorResponse } from '@nylas/core';\nimport { NylasAuthStoreType, NylasMailboxStoreType } from '../../../components';\nimport { RouterInterface } from '@/routers/router-interface';\n\nexport class NylasThreadsConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n  private nylasMailboxStore: NylasMailboxStoreType;\n  private router: RouterInterface;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasMailboxStore: NylasMailboxStoreType, router: RouterInterface) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasMailboxStore = nylasMailboxStore;\n    this.router = router;\n  }\n\n  /**\n   * Returns the list of threads.\n   * @todo Re-think how we handle pagination (previous/next page tokens) - there is a separation of logic here that might be confusing.\n   * @param {Partial<ThreadQueryParameters> | undefined} overrideQueryParams The query parameters to override from the store.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateState Whether to update the state or not (default: true).\n   * @returns {Promise<Thread[]>}\n   */\n  public async getThreads(\n    overrideQueryParams?: Partial<ThreadQueryParameters>,\n    updateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite',\n    updateState: boolean = true,\n  ): Promise<Thread[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Set the state to loading.\n    if (updateState) {\n      this.nylasMailboxStore.state.state = 'loading';\n    }\n\n    // Build the URL with the query parameters\n    const queryParams = overrideQueryParams || this.nylasMailboxStore.state.threadsQueryParams;\n    const params = new URLSearchParams();\n    for (const key in queryParams) {\n      const value = queryParams[key as keyof typeof queryParams]?.toString();\n      if (typeof value !== 'undefined' && value !== null) {\n        params.append(key, value);\n      }\n    }\n\n    // TODO: Re-think how to update the router, this seems wrong\n    if (queryParams.search_query_native) {\n      this.router.navigate(`/?query=${queryParams.search_query_native}`, true);\n    } else if (this.nylasMailboxStore.state.threadsQueryParams.search_query_native && !queryParams.search_query_native) {\n      this.router.navigate('/', true);\n    }\n\n    // If page_token is not set, reset the previous page tokens.\n    if (!queryParams.page_token) {\n      this.nylasMailboxStore.state.previousThreadPageTokens = [];\n    }\n\n    this.nylasMailboxStore.state.threadsQueryParams = queryParams;\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads?${params.toString()}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread[]>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const threads = response.data;\n    switch (updateMethod) {\n      case 'prepend':\n        this.nylasMailboxStore.state.threads = [...threads, ...this.nylasMailboxStore.state.threads];\n        break;\n      case 'append':\n        this.nylasMailboxStore.state.threads = [...this.nylasMailboxStore.state.threads, ...threads];\n        break;\n      case 'overwrite':\n      default:\n        this.nylasMailboxStore.state.threads = threads;\n        break;\n    }\n\n    // If we have a next cursor, set it in the store.\n    if (response.next_cursor) {\n      this.nylasMailboxStore.state.nextThreadPageToken = response.next_cursor;\n    } else {\n      this.nylasMailboxStore.state.nextThreadPageToken = null;\n    }\n\n    // Set the state to ready.\n    if (updateState) {\n      this.nylasMailboxStore.state.state = 'ready';\n    }\n\n    return threads;\n  }\n\n  public async getThread(threadId: string): Promise<Thread> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Check if we have the thread in the store already.\n    const storeThread = this.nylasMailboxStore.state.threads.find(t => t.id === threadId);\n    if (storeThread) {\n      return storeThread;\n    }\n\n    // Set the state to loading.\n    this.nylasMailboxStore.state.state = 'loading';\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads/${threadId}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const thread = response.data;\n    this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {\n      if (t.id === thread.id) {\n        return thread;\n      }\n      return t;\n    });\n\n    // Set the state to ready.\n    this.nylasMailboxStore.state.state = 'ready';\n\n    return thread;\n  }\n\n  /**\n   * Returns the next page of threads.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateLoadingState Whether to update the loading state or not.\n   * @returns {Promise<Thread[]>} The previous page of threads.\n   */\n  public async nextThreadPage(updateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite', updateLoadingState: boolean = true): Promise<Thread[]> {\n    if (!this.nylasMailboxStore.state.nextThreadPageToken) {\n      throw new Error('No next page token');\n    }\n\n    // If we have a next page token, add it to the previous page tokens.\n    this.nylasMailboxStore.state.previousThreadPageTokens = Array.from(\n      new Set([...this.nylasMailboxStore.state.previousThreadPageTokens, this.nylasMailboxStore.state.threadsQueryParams.page_token ?? null]),\n    );\n\n    // Get the last next page token.\n    const nextPageToken = this.nylasMailboxStore.state.nextThreadPageToken;\n\n    return this.getThreads(\n      {\n        ...this.nylasMailboxStore.state.threadsQueryParams,\n        page_token: nextPageToken,\n      },\n      updateMethod,\n      updateLoadingState,\n    );\n  }\n\n  /**\n   * Returns the previous page of threads.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateLoadingState Whether to update the loading state or not.\n   * @returns {Promise<Thread[]>} The previous page of threads.\n   */\n  public async previousThreadPage(aupdateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite', updateLoadingState: boolean = true): Promise<Thread[]> {\n    if (!this.nylasMailboxStore.state.previousThreadPageTokens.length) {\n      throw new Error('No previous page token');\n    }\n\n    // Remove the the last two next page tokens.\n    const previousThreadPageTokens = [...this.nylasMailboxStore.state.previousThreadPageTokens];\n    const pageToken = previousThreadPageTokens.pop();\n\n    // Update the store.\n    this.nylasMailboxStore.state.previousThreadPageTokens = previousThreadPageTokens;\n\n    return this.getThreads(\n      {\n        ...this.nylasMailboxStore.state.threadsQueryParams,\n        page_token: pageToken ?? undefined,\n      },\n      aupdateMethod,\n      updateLoadingState,\n    );\n  }\n\n  /**\n   * Updates the thread query parameters in the store.\n   * @param params Partial<ThreadQueryParameters>\n   * @returns {void}\n   */\n  public updateThreadQueryParams(params: Partial<ThreadQueryParameters>): void {\n    this.nylasMailboxStore.state.threadsQueryParams = {\n      ...this.nylasMailboxStore.state.threadsQueryParams,\n      ...params,\n    };\n  }\n\n  /**\n   * Back to the mailbox.\n   */\n  public back(): void {\n    this.router.navigate('/', true);\n    this.nylasMailboxStore.state.selectedThread = null;\n  }\n\n  /**\n   * Unselects a thread.\n   */\n  public unSelectThread(): void {\n    this.nylasMailboxStore.state.selectedThread = null;\n  }\n\n  /**\n   * Selects a thread.\n   * @param {Thread} thread The thread to select.\n   * @returns {Promise<void>}\n   */\n  public async selectThread(thread: Thread): Promise<void> {\n    this.router.navigate(`/thread/${thread.id}`, true);\n    this.nylasMailboxStore.state.selectedThread = thread;\n\n    // Mark the thread as read (async) if it is unread.\n    if (thread.unread) {\n      this.markThreadAsRead(thread).catch(error => {\n        debug('Error marking thread as read', error);\n      });\n    }\n  }\n\n  /**\n   * Marks a thread as read.\n   * @param thread\n   * @returns {Promise<Thread>}\n   */\n  public async markThreadAsRead(thread: Thread): Promise<Thread> {\n    return this.updateThread(thread, { unread: false });\n  }\n\n  /**\n   * Updates a thread.\n   * @param thread The thread to update.\n   * @returns {Promise<Thread>}\n   */\n  public async updateThread(thread: Thread, updateThread: Partial<Thread>): Promise<Thread> {\n    // Make sure we have an authenticated user.\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a modify scope at least.\n    if (!this.nylasAuth.hasScopeByType('email', 'modify')) {\n      throw new Error('Missing thread:modify scope');\n    }\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads/${thread.id}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread>>(path, 'PUT', updateThread);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Update the thread in the store.\n    const updatedThread = response.data;\n    this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {\n      if (t.id === updatedThread.id) {\n        return updatedThread;\n      }\n      return t;\n    });\n    this.nylasMailboxStore.state.selectedThread = updatedThread;\n\n    return updatedThread;\n  }\n}\n","import { Folder, NylasAPIError, NylasAuthType, NylasResponse, isNylasErrorResponse } from '@nylas/core';\nimport { NylasAuthStoreType, NylasMailboxStoreType } from '../../../components';\n\nexport class NylasFoldersConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n  private nylasMailboxStore: NylasMailboxStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasMailboxStore: NylasMailboxStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasMailboxStore = nylasMailboxStore;\n  }\n\n  /**\n   * Returns the list of folders.\n   */\n  public async getFolders(): Promise<Folder[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Set the state to loading.\n    this.nylasMailboxStore.state.state = 'loading';\n\n    // Make the API request.\n    const path = `/v3/grants/me/folders`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Folder[]>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const folders = response.data;\n    this.nylasMailboxStore.state.folders = folders;\n\n    // Set the state to ready.\n    this.nylasMailboxStore.state.state = 'ready';\n\n    return folders;\n  }\n\n  public async selectFolder(folder: Folder) {\n    this.nylasMailboxStore.state.threadsQueryParams = {\n      in: folder.id,\n      ...(this.nylasMailboxStore.state.threadsQueryParams || {}),\n    };\n  }\n}\n","import { debug } from '@/utils/utils';\nimport { RouteListener, RouteParams, RoutePath, RouterInterface } from './router-interface';\n\nexport class PolyFillHashChangeEvent extends Event {\n  oldURL?: string;\n  newURL?: string;\n\n  constructor(type: string, eventInitDict: HashChangeEventInit) {\n    super(type, eventInitDict);\n    this.oldURL = eventInitDict.oldURL;\n    this.newURL = eventInitDict.newURL;\n  }\n}\n\nexport class HashRouter implements RouterInterface {\n  private routeChangeListeners: [route: RoutePath, RouteListener<any>][] = [];\n\n  constructor() {\n    debug('HashRouter constructor');\n  }\n\n  // Destroy the router\n  public destroy(): void {\n    debug('HashRouter destroy');\n    window.removeEventListener('hashchange', this.onRouteChange.bind(this));\n  }\n\n  // Initialize the router\n  public init(): void {\n    debug('HashRouter init');\n    window.addEventListener('hashchange', this.onRouteChange.bind(this));\n\n    // Trigger the initial route change\n    if (typeof HashChangeEvent !== 'undefined') {\n      const event: HashChangeEvent = new HashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event);\n    } else {\n      const event: Event = new PolyFillHashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event as HashChangeEvent);\n    }\n  }\n\n  public addRouteChangeListener<Path extends RoutePath>(route: Path, listener: RouteListener<Path>): void {\n    debug('HashRouter addRouteChangeListener');\n    this.routeChangeListeners.push([route, listener]);\n  }\n\n  public navigate(route: string, shallow: boolean): void {\n    debug('HashRouter navigate');\n\n    // If we're navigating shallow, don't add a new history entry\n    if (shallow) {\n      return window.history.pushState(null, '', `#${route}`);\n    }\n\n    window.location.hash = route;\n  }\n\n  public setRoute(route: string): void {\n    debug('HashRouter setRoute');\n    window.location.hash = route;\n  }\n\n  // Matches a route and executes the callback\n  public matchRoute(route: string, path: string): boolean {\n    const routeParts = route.split('/');\n    const pathParts = path.split('/');\n\n    // If the route is `/` an the hash is empty, match the route\n    debug(`HashRouter matchRoute route=${route} path=${path}`, { routeParts, pathParts });\n    if (routeParts[1] === '' && pathParts[0] === '') {\n      return true;\n    }\n\n    if (routeParts.length !== pathParts.length) {\n      return false;\n    }\n\n    for (let i = 0; i < routeParts.length; i++) {\n      const routePart = routeParts[i];\n      const pathPart = pathParts[i];\n      if (routePart.startsWith(':')) {\n        continue;\n      }\n      if (routePart !== pathPart) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Parse the route and return the route params\n  public getRouteParams<Path extends RoutePath>(route: Path): RouteParams<Path> {\n    debug('HashRouter getRouteParams');\n    const routeParams: RouteParams<Path> = {} as RouteParams<Path>;\n    const routeParts = route.split('/');\n    const routeConfigParts = window.location.hash.split('/');\n    routeParts.forEach((routePart, index) => {\n      if (routePart.startsWith(':')) {\n        const key = routePart.substring(1) as keyof RouteParams<Path>;\n        routeParams[key] = routeConfigParts[index] as RouteParams<Path>[keyof RouteParams<Path>]; // Cast the value to string\n      }\n    });\n    return routeParams;\n  }\n\n  public getRouteWithParams(route: string, routeParams: Record<string, any>): string {\n    debug('HashRouter getRouteWithParams');\n    let routeWithParams = route;\n    Object.keys(routeParams).forEach(key => {\n      routeWithParams = routeWithParams.replace(`:${key}`, routeParams[key]);\n    });\n    return routeWithParams;\n  }\n\n  public getRoute(): string {\n    debug('HashRouter getRoute');\n    return window.location.hash;\n  }\n\n  public onRouteChange(event: HashChangeEvent): void {\n    this.routeChangeListeners.forEach(async ([route, listener]) => {\n      const path = event.newURL.indexOf('#') === -1 ? '' : event.newURL.substring(event.newURL.indexOf('#') + 1);\n      debug(`HashRouter onRouteChange route=${route} path=${path}`, { event });\n      if (!this.matchRoute(route, path)) {\n        debug(`HashRouter onRouteChange route=${route} path=${path} does not match`);\n        return;\n      }\n      const routeParams = this.getRouteParams(route) as RouteParams<RoutePath>;\n      await listener(route, path, routeParams);\n    });\n  }\n\n  public getBasePath(): string {\n    debug('HashRouter getBasePath');\n    return '';\n  }\n}\n","import { TokenInfo } from '@nylas/core/dist/auth';\nimport { createStore } from '@stencil/store';\nimport { DataState } from '..';\n\nexport interface NylasAuthStoreState {\n  isAuthenticated: boolean;\n  tokenInfo: TokenInfo | null;\n  state: DataState;\n}\n\nexport type NylasAuthStoreType = ReturnType<typeof CreateNylasAuthStore>;\n\nexport function CreateNylasAuthStore(defaultState: Partial<NylasAuthStoreState> = {}) {\n  const defaultNylasStoreState: NylasAuthStoreState = {\n    isAuthenticated: false,\n    tokenInfo: null,\n    state: 'ready',\n    ...defaultState,\n  };\n  const store = createStore<NylasAuthStoreState>(defaultNylasStoreState);\n\n  /**\n   * Reset the Nylas store to its default state.\n   * There is something wrong with the stencil/store reset method,\n   * so we have to do it via this hack.\n   */\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n","import type { Folder, Message, MessageQueryParameters, Thread, ThreadQueryParameters } from '@nylas/core';\nimport { createStore } from '@stencil/store';\nimport { DataState } from '../components';\n\nexport interface NylasMailboxStoreState {\n  state: DataState;\n  messages: Message[];\n  threads: Thread[];\n  folders: Folder[];\n  selectedThread: Thread | null;\n  selectedFolder: string;\n  searchQuery: string;\n\n  nextThreadPageToken: string | null;\n  previousThreadPageTokens: (string | null)[];\n  hasNextThreadPage: boolean;\n  hasPreviousThreadPage: boolean;\n  threadsQueryParams: Partial<ThreadQueryParameters>;\n  messgeQueryParams: Partial<MessageQueryParameters>;\n}\n\nexport type NylasMailboxStoreType = ReturnType<typeof CreateNylasMailboxStore>;\n\nexport function CreateNylasMailboxStore(defaultState: Partial<NylasMailboxStoreState> = {}) {\n  const defaultNylasStoreState: NylasMailboxStoreState = {\n    state: 'ready',\n\n    messages: [],\n    threads: [],\n    folders: [],\n    selectedThread: null,\n    nextThreadPageToken: null,\n    previousThreadPageTokens: [],\n    searchQuery: '',\n\n    hasNextThreadPage: false,\n    hasPreviousThreadPage: false,\n\n    selectedFolder: 'inbox',\n\n    threadsQueryParams: {\n      in: 'inbox',\n    },\n    messgeQueryParams: {\n      fields: 'include_headers',\n    },\n    ...defaultState,\n  };\n\n  const store = createStore<NylasMailboxStoreState>({ ...defaultNylasStoreState });\n\n  // Set our hasNextThreadPage if nextThreadPageToken is not null.\n  store.onChange('nextThreadPageToken', nextThreadPageToken => {\n    store.set('hasNextThreadPage', nextThreadPageToken !== null);\n  });\n  // Set our hasPreviousThreadPage if previousThreadPageTokens is not empty.\n  store.onChange('previousThreadPageTokens', previousThreadPageTokens => {\n    store.set('hasPreviousThreadPage', previousThreadPageTokens.length > 0);\n  });\n\n  // When threadsQueryParams changes...\n  store.onChange('threadsQueryParams', threadsQueryParams => {\n    // set our selectedFolder to the in param.\n    store.set('selectedFolder', threadsQueryParams.in || 'inbox');\n    // set our searchQuery to the search_query_native param.\n    store.set('searchQuery', threadsQueryParams.search_query_native || '');\n  });\n\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n"],"version":3}