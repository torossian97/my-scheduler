{"version":3,"names":["ErrorCategory","ComponentErrorType","APIErrorType","Errors","constructor","this","component","_title","category","Component","title","endtime_not_in_future","message","no_booking_info","no_timeslot_selected","no_timezone_selected","no_booking_id","invalid_start_time","invalid_end_time","invalid_timezone","api","Api","invalid_session","general_error","internal_error","invalid_request_error","timeslot_not_available","NylaSchedulerAPIConnector","schedulerAPIURL","schedulerStore","sessionId","configId","errors","getHeaders","Authorization","makeAPIRequest","path","method","body","headers","schedulerURL","URL","pathname","response","fetch","decodeURIComponent","toString","Origin","window","location","origin","data","json","error","type","selectDate","date","set","selectTime","time","selectTimezone","timezone","toggleAdditionalData","value","setParticipantName","name","bookingInfo","state","primaryParticipant","setParticipantEmail","email","resetStoreStateAndFetchAvailability","today","Date","startTime","getFullYear","getMonth","getTime","endTime","result","getAvailability","firstAvailableDate","get","find","timeslot","start_time","_selectedDate","setReschedule","bookingID","setCancel","resetCancel","bookTimeslot","selectedTimeslot","selectedTimezone","guests","additional_fields","additionalFields","configIdParam","url","JSON","stringify","guest","end_time","errorType","getUISettings","undefined","params","URLSearchParams","now","nowTime","startOfMonth","Math","floor","endOfMonth","append","encodeURIComponent","queryString","availability","time_slots","map","availabilityTimeslotsFiltered","filter","cancelBooking","bookingId","action","booking_id","rescheduleBooking","apiErrors","componentErrors","time_zone","CreateNylasSchedulerStore","defaultState","defaultNylasStoreState","selectedDate","selectedLanguage","navigator","language","Intl","DateTimeFormat","resolvedOptions","timeZone","showBookingForm","selectableDates","eventInfo","cancelledEventInfo","isLoading","nylasBranding","debug","store","createStore","onChange","reset","key"],"sources":["src/connector/nylas-scheduler-connector/errors/index.ts","src/connector/shared/api/scheduler.ts","src/stores/scheduler-store.ts"],"sourcesContent":["export enum ErrorCategory {\n  Component = 'component',\n  Api = 'api',\n  Auth = 'auth',\n}\n\nexport interface ErrorDetails {\n  title: string;\n  message: string;\n  category: ErrorCategory;\n}\n\nexport enum ComponentErrorType {\n  endtime_not_in_future = 'endtime_not_in_future',\n  no_booking_info = 'no_booking_info',\n  no_timeslot_selected = 'no_timeslot_selected',\n  no_timezone_selected = 'no_timezone_selected',\n  no_booking_id = 'no_booking_id',\n  invalid_start_time = 'invalid_start_time',\n  invalid_end_time = 'invalid_end_time',\n  invalid_timezone = 'invalid_timezone',\n}\n\nexport enum APIErrorType {\n  invalid_session = 'invalid_session',\n  general_error = 'general_error',\n  internal_error = 'internal_error',\n  invalid_request_error = 'invalid_request_error',\n  timeslot_not_available = 'timeslot_not_available',\n}\n\nexport class Errors {\n  component = (_title: string): Record<ComponentErrorType, (message?: string) => ErrorDetails> => {\n    const category = ErrorCategory.Component;\n    const title = `${_title} error`;\n    return {\n      endtime_not_in_future: (message: string = '\"endtime\" can not be in the future') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_booking_info: (message: string = 'No booking info provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_timeslot_selected: (message: string = 'No timeslot selected') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_timezone_selected: (message: string = 'No timezone selected') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_booking_id: (message: string = 'No booking id provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_start_time: (message: string = 'Invalid start time') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_end_time: (message: string = 'Invalid end time') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_timezone: (message: string = 'Invalid timezone') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n    };\n  };\n\n  api = (_title: string): Record<APIErrorType, (message: string) => ErrorDetails> => {\n    const category = ErrorCategory.Api;\n    const title = `${_title} error`;\n\n    return {\n      invalid_session: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      general_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      internal_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_request_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      timeslot_not_available: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n    };\n  };\n}\n","import { AvailabilityResponse, NylasEvent, UISettingsResponse } from '@/common/types';\nimport { NylasSchedulerStoreType } from '../../../components';\nimport type { NylasErrorResponse, NylasResponse, NylasSchedulerBookingData, NylasSchedulerResponse, Timeslot } from '@nylas/core';\nimport { APIErrorType, Errors } from '@/connector/nylas-scheduler-connector/errors';\n\ntype NylasSchedulerAPIConnectorOptions = {\n  schedulerAPIURL: string;\n  schedulerStore: NylasSchedulerStoreType;\n  sessionId?: string;\n  configId?: string;\n};\n\n/**\n * NylaSchedulerConnector\n * This class is used to make API requests to the scheduler.\n */\nexport class NylaSchedulerAPIConnector {\n  private schedulerStore: NylasSchedulerStoreType;\n  private schedulerAPIURL: string;\n  private sessionId: string | undefined;\n  private configId: string | undefined;\n  private errors = new Errors();\n\n  constructor({ schedulerAPIURL, schedulerStore, sessionId, configId }: NylasSchedulerAPIConnectorOptions) {\n    this.schedulerStore = schedulerStore;\n    this.schedulerAPIURL = schedulerAPIURL;\n    this.sessionId = sessionId;\n    this.configId = configId;\n  }\n\n  private getHeaders() {\n    return !this.configId\n      ? {\n          Authorization: `Bearer ${this.sessionId}`,\n        }\n      : {};\n  }\n\n  /**\n   * Makes an API request to the scheduler.\n   * @param path The path to the API endpoint.\n   * @param method The HTTP method.\n   * @param body The request body (if any).\n   * @returns {Promise<T>}\n   */\n  public async makeAPIRequest<T>(path: string, method: string, body: string | undefined, headers = {}): Promise<NylasResponse<T>> {\n    try {\n      const schedulerURL = new URL(this.schedulerAPIURL);\n      schedulerURL.pathname = path;\n      const response = await fetch(decodeURIComponent(schedulerURL.toString()), {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          'Origin': window.location.origin,\n          ...headers,\n        },\n        body,\n      });\n      // The server returns a json object for errors: eg.\n      // {\n      //     \"request_id\": \"<request_id>\",\n      //     \"error\": {\n      //         \"type\": \"not_found_error\",\n      //         \"message\": \"Session not found\"\n      //     }\n      // }\n      const data = await response.json();\n      return data as NylasResponse<T>;\n    } catch (error: any) {\n      // NOTE: current server implementation doesn't return a JSON object for errors on some endpoints\n      // handle this case by returning the error response as a string to be handled downstream\n      return {\n        error: {\n          message: error.message,\n          title: 'API request failed',\n          type: 'api',\n        },\n      } as NylasErrorResponse;\n    }\n  }\n\n  /**\n   * Selects a date in the scheduler.\n   */\n  public selectDate(date: Date) {\n    this.schedulerStore.set('selectedDate', date);\n    this.schedulerStore.set('selectedTimeslot', null);\n  }\n\n  /**\n   * Selects a time in the scheduler.\n   */\n  public selectTime(time: Timeslot) {\n    this.schedulerStore.set('selectedTimeslot', time);\n  }\n\n  /**\n   * Sets the timezone in the scheduler.\n   */\n  public selectTimezone(timezone: string) {\n    this.schedulerStore.set('selectedTimezone', timezone);\n  }\n\n  /**\n   * Toggles showBookingForm\n   * @param value boolean\n   */\n  public toggleAdditionalData(value: boolean) {\n    this.schedulerStore.set('showBookingForm', value);\n  }\n\n  /**\n   * Set/update the name of the participant booking the event.\n   */\n  public setParticipantName(name: string) {\n    const { bookingInfo } = this.schedulerStore.state;\n    this.schedulerStore.set('bookingInfo', {\n      ...bookingInfo,\n      primaryParticipant: {\n        ...(bookingInfo?.primaryParticipant as NylasSchedulerBookingData['primaryParticipant']),\n        name,\n      },\n    });\n  }\n\n  /**\n   * Set/update the email of the participant booking the event.\n   */\n  public setParticipantEmail(email: string) {\n    const { bookingInfo } = this.schedulerStore.state;\n    this.schedulerStore.set('bookingInfo', {\n      ...bookingInfo,\n      primaryParticipant: {\n        ...(bookingInfo?.primaryParticipant as NylasSchedulerBookingData['primaryParticipant']),\n        email,\n      },\n    });\n  }\n\n  private async resetStoreStateAndFetchAvailability() {\n    const today = new Date();\n    // Refetch availability\n    const startTime = new Date(today.getFullYear(), today.getMonth(), 1).getTime() / 1000;\n    const endTime = new Date(today.getFullYear(), today.getMonth() + 1, 1).getTime() / 1000;\n    const result = await this.getAvailability(startTime, endTime);\n    // Set selected date to first available date\n    const firstAvailableDate = this.schedulerStore.get('availability').find((timeslot: any) => new Date(timeslot.start_time) > new Date());\n    let _selectedDate = today;\n    if (firstAvailableDate) {\n      _selectedDate = firstAvailableDate.start_time;\n    }\n    this.schedulerStore.set('selectedDate', _selectedDate);\n    // Reset store state\n    this.schedulerStore.set('eventInfo', null);\n    this.schedulerStore.set('showBookingForm', false);\n    this.schedulerStore.set('selectedTimeslot', null);\n\n    return result;\n  }\n\n  /**\n   * Set reschedule booking id\n   */\n  public async setReschedule(bookingID: string) {\n    // Set reschedule booking id\n    const result = await this.resetStoreStateAndFetchAvailability();\n    this.schedulerStore.set('rescheduleBookingId', bookingID);\n    return result;\n  }\n\n  /**\n   * Set cancel booking id\n   */\n  public async setCancel(bookingID: string) {\n    this.schedulerStore.set('cancelBookingId', bookingID);\n  }\n\n  public async resetCancel() {\n    const result = await this.resetStoreStateAndFetchAvailability();\n    this.schedulerStore.set('cancelBookingId', '');\n    this.schedulerStore.set('cancelledEventInfo', null);\n    return result;\n  }\n\n  /**\n   * Book the selected timeslot.\n   * @param data The booking info.\n   * @returns {Promise<NylasResponse<NylasEvent>>}\n   */\n  public async bookTimeslot(data?: NylasSchedulerBookingData & { timeslot?: Timeslot }): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    const { selectedTimeslot, selectedTimezone, bookingInfo } = this.schedulerStore.state;\n    if (!data && !bookingInfo) {\n      return { error: this.errors.component('Booking').no_booking_info() };\n    }\n\n    const timeslot = data?.timeslot || selectedTimeslot;\n    if (!timeslot) {\n      return { error: this.errors.component('Create Booking').no_timeslot_selected() };\n    }\n\n    const timezone = data && data?.timezone ? data?.timezone : selectedTimezone;\n\n    if (!timezone) {\n      return { error: this.errors.component('Create Booking').no_timezone_selected() };\n    }\n\n    const primaryParticipant = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;\n    const guests = data ? data?.guests || [] : bookingInfo?.guests || [];\n    const additional_fields = data ? { ...data?.additionalFields, guests } : { ...bookingInfo?.additionalFields, guests };\n\n    const headers = this.getHeaders();\n    const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';\n    const url = `/v3/scheduling/bookings${configIdParam}`;\n\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'POST',\n      JSON.stringify({\n        additional_fields,\n        guest: { ...primaryParticipant },\n        start_time: timeslot.start_time.getTime() / 1000,\n        end_time: timeslot.end_time.getTime() / 1000,\n        timezone: timezone,\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api('Create Booking')) {\n        error = this.errors.api('Create Booking')[errorType as APIErrorType](error?.message || error?.title || 'Something went wrong');\n      }\n      return { error };\n    }\n\n    if ('data' in response) {\n      this.schedulerStore.set('eventInfo', response?.data);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Get UI settings for the scheduler.\n   */\n  public async getUISettings(): Promise<NylasSchedulerResponse<UISettingsResponse>> {\n    this.schedulerStore.set('isLoading', true);\n    const headers = this.getHeaders();\n    const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';\n    const url = `/v3/scheduling/ui-settings${configIdParam}`;\n\n    const response = await this.makeAPIRequest<UISettingsResponse>(url, 'GET', undefined, headers);\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api('Get UI Settings')) {\n        error = this.errors.api('Get UI Settings')[errorType as APIErrorType](error?.message || error?.title || 'Something went wrong');\n      }\n      return { error };\n    }\n    if ('data' in response) {\n      this.schedulerStore.set('configSettings', response.data);\n    }\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Gets the availability for a page.\n   * @param startTime The start time.\n   * @param endTime The end time.\n   * @returns {Promise<AvailabilityResponse>}\n   */\n  public async getAvailability(startTime: number = 0, endTime: number = 0): Promise<NylasSchedulerResponse<AvailabilityResponse>> {\n    this.schedulerStore.set('isLoading', true);\n    const params = new URLSearchParams();\n    const now = new Date();\n    const nowTime = now.getTime();\n\n    if (endTime && endTime < nowTime / 1000) {\n      this.schedulerStore.set('isLoading', false);\n      const error = this.errors.component('Get Availability').endtime_not_in_future();\n      return { error };\n    }\n\n    // Calculate the start of the current month if startTime is not provided\n    if (!startTime) {\n      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n      startTime = Math.floor(startOfMonth.getTime() / 1000); // Convert to UNIX timestamp in seconds\n    }\n\n    // Calculate the end of the current month if endTime is not provided\n    if (!endTime) {\n      const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Setting day to 0 gets the last day of the previous month, so in this case, the last day of the current month\n      endTime = Math.floor(endOfMonth.getTime() / 1000); // Convert to UNIX timestamp in seconds\n    }\n\n    params.append('start_time', encodeURIComponent(startTime.toString()));\n    params.append('end_time', encodeURIComponent(endTime.toString()));\n    if (this.configId) {\n      params.append('configuration_id', encodeURIComponent(this.configId));\n    }\n    const queryString = params.toString();\n    const url = `/v3/scheduling/availability${queryString ? `?${queryString}` : ''}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<AvailabilityResponse>(decodeURIComponent(url), 'GET', undefined, headers);\n\n    if ('error' in response) {\n      this.schedulerStore.set('availability', []);\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api('Get Availability')) {\n        error = this.errors.api('Get Availability')[errorType as APIErrorType](error?.message || error?.title || 'Something went wrong');\n      }\n      return { error };\n    }\n\n    if ('data' in response) {\n      const availability =\n        response.data?.time_slots?.map(timeslot => {\n          return {\n            ...timeslot,\n            start_time: new Date(timeslot.start_time * 1000),\n            end_time: new Date(timeslot.end_time * 1000),\n          };\n        }) || [];\n\n      // Filter out timeslots that are in the past\n      const availabilityTimeslotsFiltered = availability.filter(timeslot => timeslot.start_time.getTime() > nowTime);\n      this.schedulerStore.set('availability', availabilityTimeslotsFiltered);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Cancels a booking.\n   * @param bookingId The booking ID.\n   */\n  public async cancelBooking(bookingId: string): Promise<NylasSchedulerResponse<Partial<NylasEvent>>> {\n    this.schedulerStore.set('isLoading', true);\n    if (!bookingId) {\n      return { error: this.errors.component('Cancel Booking').no_booking_id() };\n    }\n    const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<Partial<NylasEvent>>(\n      decodeURIComponent(url),\n      'DELETE',\n      JSON.stringify({\n        action: 'cancel',\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api('Cancel Booking')) {\n        error = this.errors.api('Cancel Booking')[errorType as APIErrorType](error?.message || error?.title || 'Something went wrong');\n      }\n      return { error };\n    }\n\n    this.schedulerStore.set('cancelledEventInfo', {\n      booking_id: bookingId,\n    });\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Reschedules a booking.\n   * @param bookingId The booking ID.\n   * @param data The booking info.\n   * @returns {Promise<NylasResponse<NylasEvent>>}\n   */\n  public async rescheduleBooking(bookingId: string, data: NylasSchedulerBookingData): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    if (!bookingId) {\n      return { error: this.errors.component('Reschedule Booking').no_booking_id() };\n    }\n    const apiErrors = this.errors.api('Reschedule Booking');\n    const componentErrors = this.errors.component('Reschedule Booking');\n    const { bookingInfo, selectedTimeslot, selectedTimezone } = this.schedulerStore.state;\n    // Validate data\n    const { startTime, endTime, timezone } = data;\n    const start_time = startTime || selectedTimeslot?.start_time;\n\n    if (!start_time) {\n      return { error: componentErrors.invalid_start_time('Please pass \"startTime\" in data or set \"selectedTimeslot\" in the defaultSchedulerState.') };\n    }\n    const end_time = endTime || selectedTimeslot?.end_time;\n    if (!end_time) {\n      return { error: componentErrors.invalid_end_time('Please pass \"endTime\" in data or set \"selectedTimeslot\" in the defaultSchedulerState.') };\n    }\n    const time_zone = timezone || selectedTimezone;\n    if (!time_zone) {\n      return { error: componentErrors.invalid_timezone('Please pass \"timezone\" in data or set \"selectedTimezone\" in the defaultSchedulerState.') };\n    }\n\n    const primaryParticipant = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;\n    const guests = data ? data?.guests || [] : bookingInfo?.guests || [];\n    const additional_fields = data ? { ...data?.additionalFields, guests } : { ...bookingInfo?.additionalFields, guests };\n\n    const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'PATCH',\n      JSON.stringify({\n        start_time: start_time.getTime() / 1000,\n        end_time: end_time.getTime() / 1000,\n        time_zone,\n        additional_fields,\n        guest: { ...primaryParticipant },\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in apiErrors) {\n        error = apiErrors[errorType as APIErrorType](error?.message || error?.title || 'Something went wrong');\n      }\n    }\n\n    if ('data' in response) this.schedulerStore.set('eventInfo', response?.data);\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n}\n","import { DataState, NylasEvent } from '@/common/types';\nimport { debug } from '@/utils/utils';\nimport { NylasSchedulerBookingData, Timeslot } from '@nylas/core';\nimport { createStore } from '@stencil/store';\n\nexport type AvailabilityTimeslot = {\n  emails: string[];\n  start_time: Date;\n  end_time: Date;\n};\n\nexport type LoadingState = {\n  api: 'availability' | 'createBooking' | 'cancelBooking' | 'rescheduleBooking';\n};\n\nexport type ConfigSettings = {\n  scheduler: {\n    available_days_in_future: number;\n    min_cancellation_notice: number;\n  };\n  organizer: {\n    name: string;\n    email: string;\n  };\n};\n\nexport interface NylasSchedulerStoreState {\n  selectedDate: Date | null;\n  selectedLanguage: string;\n  selectedTimezone: string;\n  selectedTimeslot: Timeslot | null;\n  showBookingForm: boolean;\n  selectableDates: Date[] | null;\n  availability: AvailabilityTimeslot[];\n  state: DataState;\n  eventInfo: NylasEvent | null;\n  cancelledEventInfo: Partial<NylasEvent> | null;\n  bookingInfo?: NylasSchedulerBookingData;\n  rescheduleBookingId?: string;\n  cancelBookingId?: string;\n  isLoading: boolean;\n  nylasBranding?: boolean;\n  configSettings?: ConfigSettings;\n}\n\nexport type NylasSchedulerStoreType = ReturnType<typeof CreateNylasSchedulerStore>;\n\nexport function CreateNylasSchedulerStore(defaultState: Partial<NylasSchedulerStoreState> = {}) {\n  const defaultNylasStoreState: NylasSchedulerStoreState = {\n    selectedDate: null,\n    selectedLanguage: navigator.language,\n    selectedTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    selectedTimeslot: null,\n    showBookingForm: false,\n    selectableDates: null,\n    availability: [],\n    state: 'ready',\n    eventInfo: null,\n    cancelledEventInfo: null,\n    isLoading: false,\n    nylasBranding: true,\n    ...defaultState,\n  };\n  debug(`[defaultNylasStoreState]: `, defaultNylasStoreState);\n  const store = createStore<NylasSchedulerStoreState>(defaultNylasStoreState);\n\n  store.onChange('availability', availability => {\n    debug(`[availability]: `, availability);\n    const selectableDates = availability.map(timeslot => timeslot.start_time);\n    debug(`[selectableDates]: `, selectableDates);\n    store.set('selectableDates', selectableDates);\n  });\n\n  /**\n   * Reset the Nylas store to its default state.\n   * There is something wrong with the stencil/store reset method,\n   * so we have to do it via this hack.\n   */\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n"],"mappings":"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"}