import dayjs from "dayjs";
import { RRule } from "rrule";
export function format(first, middle, last) {
    return (first || '') + (middle ? ` ${middle}` : '') + (last ? ` ${last}` : '');
}
export function removeUndefined(obj) {
    return Object.keys(obj).reduce((acc, key) => {
        if (obj[key] !== undefined) {
            acc[key] = obj[key];
        }
        return acc;
    }, {});
}
export function debug(...args) {
    if (window && window.localStorage && window.localStorage.getItem('debug')) {
        console.group(...args);
        console.trace();
        console.groupEnd();
    }
}
export function error(...args) {
    console.error(...args);
}
export function uniqueID() {
    return Math.random().toString(36).substr(2, 9);
}
export function formatEventName(propKey) {
    return propKey.toString().replace(/^on/, '');
}
export function formatDateTime(dateTimestamp) {
    const date = new Date(dateTimestamp * 1000);
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    if (date >= today) {
        const formatter = new Intl.DateTimeFormat('default', {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true,
        });
        return formatter.format(date);
    }
    else {
        const formatter = new Intl.DateTimeFormat('default', {
            month: 'short',
            day: 'numeric',
        });
        return formatter.format(date);
    }
}
export function formatRecipient(recipient) {
    return recipient.name ? `${recipient.name} - ${recipient.email}` : recipient.email;
}
export function formatParticipants(participants, meEmail = '', messageCount = 1, max = 3) {
    const me = participants.find(p => p.email?.toLowerCase() === meEmail.toLowerCase());
    const others = participants.filter(p => p.email?.toLowerCase() !== meEmail.toLowerCase());
    const othersCount = others.length;
    const othersString = others
        .slice(0, max)
        .map(r => r.name || r.email)
        .join(', ');
    if (othersCount === 0) {
        return me ? 'me' : '';
    }
    else if (othersCount === 1) {
        return me && messageCount > 1 ? `me, ${othersString}` : othersString;
    }
    else if (othersCount === 2) {
        return me ? `me, ${othersString}` : `${othersString}`;
    }
    else {
        return me ? `me, ${othersString}, +${othersCount - max}` : `${othersString}, +${othersCount - max}`;
    }
}
const DIVISIONS = [
    { amount: 60, name: 'seconds' },
    { amount: 60, name: 'minutes' },
    { amount: 24, name: 'hours' },
    { amount: 7, name: 'days' },
    { amount: 4.34524, name: 'weeks' },
    { amount: 12, name: 'months' },
    { amount: Number.POSITIVE_INFINITY, name: 'years' },
];
export const formatTimeAgo = (date) => {
    const formatter = new Intl.RelativeTimeFormat(undefined, {
        numeric: 'auto',
    });
    const now = new Date();
    let duration = (date.getTime() - now.getTime()) / 1000;
    for (let i = 0; i <= DIVISIONS.length; i++) {
        const division = DIVISIONS[i];
        if (Math.abs(duration) < division.amount) {
            return formatter.format(Math.round(duration), division.name);
        }
        duration /= division.amount;
    }
};
export function getLastDayOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
}
export function getFirstDayOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
}
export function getFirstHourOfDay(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0);
}
export function isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
}
export function isSameMonth(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
}
export function toTitleCase(str) {
    return str.replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
}
export function formatFolderName(folderName) {
    return folderName.replace('CATEGORY_', '').replace(/_/g, ' ');
}
export function detectHTMLOrPlainText(html) {
    const regex = /<[^>]*>/g;
    return regex.test(html) ? 'html' : 'plain';
}
export function detectIfMessageIsHTML(message) {
    const headers = message.headers;
    const contentType = (headers && headers.find(h => h.name === 'Content-Type')?.value) || '';
    const contentDisposition = (headers && headers.find(h => h.name === 'Content-Disposition')?.value) || '';
    if (contentType.includes('text/html')) {
        return true;
    }
    if (contentDisposition.includes('inline')) {
        return true;
    }
    if (message.body && detectHTMLOrPlainText(message.body) === 'html') {
        return true;
    }
    return false;
}
export function parsePlainTextToHTML(text) {
    const paragraphs = text.split('\n').filter(line => line.trim().length > 0);
    const wrappedParagraphs = paragraphs.map(paragraph => `<p>${paragraph}</p>`);
    let body = wrappedParagraphs.join('');
    const regex = /((?:https?|ftp):\/\/[^\s]+)/g;
    body = body.replace(regex, '<a href="$1">$1</a>');
    return body;
}
export function htmlToPlainText(html) {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    return doc.body.textContent || '';
}
export function getStartHourOfDay(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0);
}
export function getEndHourOfDay(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23);
}
export function get24HourTime(date) {
    return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
}
export function getUserTimezone() {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
}
export const getEventRecurrence = (recurrence) => {
    if (recurrence.includes('RRULE:')) {
        recurrence = recurrence.replace('RRULE:', '');
        return RRule.fromString(recurrence).toText();
    }
    return RRule.fromString(recurrence).toText();
};
export const validateTimeFormatInput = text => {
    if (text === '') {
        return true;
    }
    const regexPattern = /^(0[0-9]|1[0-2]|^[0-9])(:[0-5][0-9][ap]m?|:[0-5][0-9]|:[0-5]|:)?$/i;
    return regexPattern.test(text);
};
export const validateExactTimeFormat = input => {
    const regex = /^(0[1-9]|1[0-2]):([0-5][0-9])(am|pm)$/i;
    return regex.test(input);
};
export function roundToNearest15Minutes(time = null) {
    let currentTime = dayjs();
    if (time) {
        currentTime = time;
    }
    const minuteRemainder = currentTime.minute() % 15;
    let roundedTime;
    if (minuteRemainder !== 0) {
        roundedTime = currentTime.add(15 - minuteRemainder, 'minute');
    }
    else {
        roundedTime = currentTime;
    }
    return roundedTime;
}
export function autocompleteTimeFormat(input) {
    const currentTime = dayjs();
    let completedTime = '';
    const [inputHour, inputMinuteWithAmPm] = input.split(':');
    if (inputHour.length === 1) {
        completedTime += '0' + inputHour;
    }
    else if (inputHour.length === 2) {
        completedTime += inputHour;
    }
    completedTime += ':';
    if (inputMinuteWithAmPm === undefined || inputMinuteWithAmPm == '') {
        completedTime += '00';
    }
    else {
        if (inputMinuteWithAmPm.length === 1) {
            completedTime += inputMinuteWithAmPm + '0';
        }
        else {
            completedTime += inputMinuteWithAmPm;
        }
    }
    const amPmIndicator = completedTime.slice(-1);
    if (amPmIndicator === 'a') {
        completedTime += 'm';
    }
    if (amPmIndicator === 'p') {
        completedTime += 'm';
    }
    if (completedTime.slice(-1) !== 'm') {
        if (completedTime.split(':')[0] == '00') {
            completedTime += 'am';
        }
        else {
            completedTime += currentTime.format('a');
        }
    }
    return completedTime;
}
export function formatTime(time) {
    return dayjs(time, 'hh:mma');
}
export function convertTo12HourFormat(timeStr) {
    const [hoursInitial, minutes] = timeStr.split(':').map(num => parseInt(num, 10));
    let hours = hoursInitial;
    const ampm = hours >= 12 ? 'pm' : 'am';
    hours = hours % 12;
    hours = hours ? hours : 12;
    const formattedHours = hours.toString().padStart(2, '0');
    const formattedMinutes = minutes.toString().padStart(2, '0');
    return `${formattedHours}:${formattedMinutes}${ampm}`;
}
export function convertTo24HourFormat(timeStr) {
    const [time, modifier] = timeStr.split(/(am|pm)/i);
    const [hoursInitial, minutes] = time.split(':').map(num => parseInt(num, 10));
    let hours = hoursInitial;
    if (modifier.toLowerCase() === 'pm' && hours < 12) {
        hours += 12;
    }
    else if (modifier.toLowerCase() === 'am' && hours === 12) {
        hours = 0;
    }
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
}
export function timeToMinutes(time) {
    const [hours, minutesPart] = time.match(/(\d+):(\d+)(am|pm)/).slice(1);
    let minutes = parseInt(hours, 10) * 60 + parseInt(minutesPart, 10);
    if (time.includes('pm') && parseInt(hours, 10) < 12)
        minutes += 12 * 60;
    if (time.includes('am') && parseInt(hours, 10) === 12)
        minutes -= 12 * 60;
    return minutes;
}
export function minutesToTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${h}:${m < 10 ? '0' : ''}${m}`;
}
export function getBrowser() {
    const ua = navigator.userAgent;
    const isChrome = /Chrome/.test(ua) && /Google Inc/.test(navigator.vendor);
    const isSafari = /Safari/.test(ua) && /Apple Computer/.test(navigator.vendor);
    const isFirefox = /Firefox/.test(ua);
    const isIE = /Trident/.test(ua);
    const isEdgeLegacy = /Edge/.test(ua);
    const isEdgeChromium = isChrome && /Edg/.test(ua);
    if (isEdgeChromium)
        return 'Edge (Chromium)';
    if (isChrome)
        return 'Chrome';
    if (isSafari)
        return 'Safari';
    if (isFirefox)
        return 'Firefox';
    if (isIE)
        return 'Internet Explorer';
    if (isEdgeLegacy)
        return 'Edge (Legacy)';
    return 'Unknown';
}
export function dataResponse(data, error = null) {
    if (error) {
        return [null, error];
    }
    return [data, null];
}
export function parsePreviewLink(link, config) {
    const replacements = {
        'config.id': config?.id,
        'id': config?.id,
    };
    Object.keys(replacements).forEach(key => {
        link = link.replace(`{${key}}`, replacements[key]);
    });
    return link;
}
export function isNonPrintableKey(event) {
    if (event.keyCode < 48 ||
        (event.keyCode > 90 && event.keyCode < 96) ||
        (event.keyCode > 111 && event.keyCode < 186) ||
        event.keyCode > 222 ||
        event.keyCode === 32 ||
        event.keyCode === 91 ||
        event.keyCode === 92 ||
        event.keyCode === 93 ||
        (event.keyCode >= 112 && event.keyCode <= 123) ||
        (event.keyCode >= 37 && event.keyCode <= 40)) {
        return true;
    }
    if (event.ctrlKey || event.altKey || event.metaKey) {
        return true;
    }
    const shiftSpecialChars = [
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        186,
        187,
        188,
        189,
        190,
        191,
        192,
        219,
        220,
        221,
        222,
    ];
    if (event.shiftKey && shiftSpecialChars.includes(event.keyCode)) {
        return false;
    }
    return false;
}
export function addDaysToCurrentDate(startDate, days) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + days);
    currentDate.setHours(23);
    currentDate.setMinutes(59);
    currentDate.setSeconds(0);
    currentDate.setMilliseconds(0);
    return currentDate;
}
export function addMinutesToCurrentTime(startDate, minutes) {
    const currentDate = new Date(startDate);
    currentDate.setMinutes(currentDate.getMinutes() + minutes);
    return currentDate;
}
export function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
export function mergeDeep(target, source) {
    if (Array.isArray(target) && Array.isArray(source) && target !== source) {
        if (target.some(item => item.is_organizer) && source.some(item => item.is_organizer)) {
            target = target.map(participant => ({ ...participant, is_organizer: false }));
        }
        else if (!source.some(item => item.is_organizer)) {
            let foundOrganizer = false;
            target = target.map(participant => {
                if (!foundOrganizer) {
                    foundOrganizer = true;
                    return { ...participant, is_organizer: true };
                }
                return participant;
            });
        }
        return target
            .map((item, index) => {
            return source[index] ? mergeDeep(item, source[index]) : item;
        })
            .concat(source.slice(target.length));
    }
    else if (isObject(target) && isObject(source)) {
        const output = Object.assign({}, target);
        Object.keys(source).forEach(key => {
            if (isObject(source[key])) {
                if (!(key in target)) {
                    output[key] = source[key];
                }
                else {
                    output[key] = mergeDeep(target[key], source[key]);
                }
            }
            else {
                output[key] = source[key];
            }
        });
        return output;
    }
    return source;
}
//# sourceMappingURL=utils.js.map
