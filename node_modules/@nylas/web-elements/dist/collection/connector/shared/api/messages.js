import { NylasAPIError, isNylasErrorResponse } from "@nylas/core";
export class NylasMessagesConnector {
    constructor(nylasAuth, nylasAuthStore, nylasMailboxStore) {
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
        this.nylasMailboxStore = nylasMailboxStore;
    }
    async getMessages() {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        this.nylasMailboxStore.state.state = 'loading';
        const queryParams = this.nylasMailboxStore.state.messgeQueryParams;
        const params = new URLSearchParams();
        for (const key in queryParams) {
            const value = queryParams[key]?.toString();
            if (value) {
                params.append(key, value);
            }
        }
        const path = `/v3/grants/me/messages?${params.toString()}`;
        const response = await this.nylasAuth.nylasAPIRequest(path);
        if (isNylasErrorResponse(response)) {
            throw new NylasAPIError(response.error);
        }
        const messages = response.data;
        this.nylasMailboxStore.state.messages = messages;
        this.nylasMailboxStore.state.state = 'ready';
        return messages;
    }
    async getThreadMessages(threadId) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        const response = await this.nylasAuth.nylasAPIRequest(`/v3/grants/me/messages?thread_id=${threadId}&fields=include_headers`);
        if (isNylasErrorResponse(response)) {
            throw new NylasAPIError(response.error);
        }
        const messages = response.data;
        this.nylasMailboxStore.state.messages = messages;
        return messages;
    }
    downloadMessageAttachments(message) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        const blobPromises = [];
        const attachments = message.attachments || [];
        for (const attachment of attachments) {
            const blob = this.nylasAuth.nylasDownloadFileRequest(`/v3/grants/me/attachments/${attachment.id}?message_id=${message.id}`);
            blobPromises.push(blob);
        }
        return blobPromises;
    }
    async summarizeText(text) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        const response = await this.nylasAuth.nylasAPIRequest(`/v3/grants/me/mailbox/summarize`, 'POST', {
            message: {
                body: text,
            },
        }, true, this.nylasAuth.config.elementsApiUri);
        if (isNylasErrorResponse(response)) {
            throw new NylasAPIError(response.error);
        }
        return response.data.summary;
    }
    async textToSpeech(text, abortController) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing message:read-only scope');
        }
        return this.nylasAuth.nylasAPIRequest(`/v3/grants/me/mailbox/tts`, 'POST', {
            text,
        }, false, this.nylasAuth.config.elementsApiUri, {
            ...(abortController ? { signal: abortController?.signal } : {}),
        });
    }
}
//# sourceMappingURL=messages.js.map
