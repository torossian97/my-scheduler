{"version":3,"file":"auth.js","sourceRoot":"","sources":["../../../../src/connector/shared/api/auth.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,eAAe,CAAC;AAGtC,MAAM,OAAO,kBAAkB;IAI7B,YAAY,SAAwB,EAAE,cAAkC;QACtE,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAQM,KAAK,CAAC,eAAe;QAC1B,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAC;QACxD,IAAI,CAAC,eAAe,EAAE,CAAC;YAErB,IAAI,CAAC,MAAM,EAAE,CAAC;QAChB,CAAC;aAAM,CAAC;YAEN,IAAI,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,CAAC;YACpD,IAAI,SAAS,EAAE,CAAC;gBAEd,MAAM,eAAe,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;gBACtC,MAAM,oBAAoB,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;gBAE3D,IAAI,SAAS,CAAC,UAAU,IAAI,SAAS,CAAC,UAAU,GAAG,oBAAoB,GAAG,eAAe,EAAE,CAAC;oBAC1F,KAAK,CAAC,mDAAmD,CAAC,CAAC;oBAC3D,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;oBACtD,IAAI,CAAC,SAAS,EAAE,CAAC;wBACf,KAAK,CAAC,qFAAqF,CAAC,CAAC;wBAC7F,IAAI,CAAC,MAAM,EAAE,CAAC;wBACd,OAAO;oBACT,CAAC;gBACH,CAAC;gBAED,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;YAClD,CAAC;QACH,CAAC;QACD,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC;IAC9D,CAAC;IAMM,KAAK,CAAC,eAAe;QAC1B,OAAO,IAAI,CAAC,SAAS,CAAC,eAAe,EAAE,CAAC;IAC1C,CAAC;IAMM,KAAK,CAAC,YAAY;QACvB,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,CAAC;IACvC,CAAC;IAMM,KAAK,CAAC,kBAAkB;QAC7B,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;IAC7C,CAAC;IAMM,KAAK,CAAC,MAAM;QACjB,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC;IAChC,CAAC;IASM,KAAK,CAAC,wBAAwB,CAAC,MAAiB,EAAE,KAAc,EAAE,QAAiB;QACxF,OAAO,IAAI,CAAC,SAAS,CAAC,wBAAwB,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC1E,CAAC;IAOM,KAAK,CAAC,4BAA4B,CAAC,UAAkB;QAC1D,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,UAAU,CAAC,CAAC;QAChC,MAAM,IAAI,GAAG,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAE1C,IAAI,IAAI,EAAE,CAAC;YACT,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;YAC1E,IAAI,SAAS,EAAE,CAAC;gBACd,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;gBAChD,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC;gBACjD,OAAO,SAAS,CAAC;YACnB,CAAC;QACH,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;CACF","sourcesContent":["import { debug } from '@/utils/utils';\nimport { NylasAuthStoreType, NylasAuthType, TokenInfo } from '../../..';\n\nexport class NylasAuthConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n  }\n\n  /**\n   * Validates the current session and updates the store with the token info\n   * if the user is authenticated.\n   * If the user is not authenticated, the store is reset.\n   * @returns {Promise<void>}\n   */\n  public async validateSession(): Promise<void> {\n    const isAuthenticated = await this.isAccessTokenValid();\n    if (!isAuthenticated) {\n      // Reset the store if the access token is not valid\n      this.logout();\n    } else {\n      // If the user is authenticated, update the store with the token info\n      let tokenInfo = await this.nylasAuth.getTokenInfo();\n      if (tokenInfo) {\n        // If token is expired or about to expire (in 5 minutes), refresh it\n        const expireTimeCheck = 5 * 60 * 1000; // 5 minutes\n        const currentTimeInSeconds = Math.floor(Date.now() / 1000);\n\n        if (tokenInfo.expires_in && tokenInfo.expires_in - currentTimeInSeconds < expireTimeCheck) {\n          debug('[NylasAuthConnectorMixin] Refreshing access token');\n          tokenInfo = await this.nylasAuth.refreshAccessToken();\n          if (!tokenInfo) {\n            debug('[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out.');\n            this.logout();\n            return;\n          }\n        }\n\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n      }\n    }\n    this.nylasAuthStore.state.isAuthenticated = isAuthenticated;\n  }\n\n  /**\n   * Returns true if the user is authenticated.\n   * @returns {Promise<boolean>}\n   */\n  public async isAuthenticated(): Promise<boolean> {\n    return this.nylasAuth.isAuthenticated();\n  }\n\n  /**\n   * Returns the token info if the user is authenticated.\n   * @returns {Promise<TokenInfo>}\n   */\n  public async getTokenInfo(): Promise<TokenInfo | null> {\n    return this.nylasAuth.getTokenInfo();\n  }\n\n  /**\n   * Returns true if the access token is valid.\n   * @returns {Promise<boolean>}\n   */\n  public async isAccessTokenValid(): Promise<boolean> {\n    return this.nylasAuth.isAccessTokenValid();\n  }\n\n  /**\n   * Removes the token info from the store and logs the user out.\n   * @returns {Promise<void>}\n   */\n  public async logout(): Promise<void> {\n    await this.nylasAuth.logout();\n  }\n\n  /**\n   * Returns the URL to redirect the user to for authentication.\n   * @param scopes An array of scopes to request from the user.\n   * @param email The email address of the user to authenticate.\n   * @param provider The provider to use for authentication.\n   * @returns {Promise<string>}\n   */\n  public async getHostedAuthRedirectURL(scopes?: string[], email?: string, provider?: string): Promise<string> {\n    return this.nylasAuth.getHostedAuthRedirectURL(scopes, email, provider);\n  }\n\n  /**\n   * Exchanges the auth code for a token info and updates the store.\n   * @param currentUrl The current URL of the page.\n   * @returns {Promise<TokenInfo | null>}\n   */\n  public async manageHostedAuthCodeExchange(currentUrl: string): Promise<TokenInfo | null> {\n    const url = new URL(currentUrl);\n    const code = url.searchParams.get('code');\n\n    if (code) {\n      const tokenInfo = await this.nylasAuth.exchangeAuthCodeForTokenInfo(code);\n      if (tokenInfo) {\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n        this.nylasAuthStore.state.isAuthenticated = true;\n        return tokenInfo;\n      }\n    }\n\n    return null;\n  }\n}\n"]}