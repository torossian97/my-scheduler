import { Errors } from "../../nylas-scheduler-connector/errors/index";
export class NylaSchedulerAPIConnector {
    constructor({ schedulerAPIURL, schedulerStore, sessionId, configId }) {
        this.errors = new Errors();
        this.schedulerStore = schedulerStore;
        this.schedulerAPIURL = schedulerAPIURL;
        this.sessionId = sessionId;
        this.configId = configId;
    }
    getHeaders() {
        return !this.configId
            ? {
                Authorization: `Bearer ${this.sessionId}`,
            }
            : {};
    }
    async makeAPIRequest(path, method, body, headers = {}) {
        try {
            const schedulerURL = new URL(this.schedulerAPIURL);
            schedulerURL.pathname = path;
            const response = await fetch(decodeURIComponent(schedulerURL.toString()), {
                method,
                headers: {
                    'Content-Type': 'application/json',
                    'Origin': window.location.origin,
                    ...headers,
                },
                body,
            });
            const data = await response.json();
            return data;
        }
        catch (error) {
            return {
                error: {
                    message: error.message,
                    title: 'API request failed',
                    type: 'api',
                },
            };
        }
    }
    selectDate(date) {
        this.schedulerStore.set('selectedDate', date);
        this.schedulerStore.set('selectedTimeslot', null);
    }
    selectTime(time) {
        this.schedulerStore.set('selectedTimeslot', time);
    }
    selectTimezone(timezone) {
        this.schedulerStore.set('selectedTimezone', timezone);
    }
    toggleAdditionalData(value) {
        this.schedulerStore.set('showBookingForm', value);
    }
    setParticipantName(name) {
        const { bookingInfo } = this.schedulerStore.state;
        this.schedulerStore.set('bookingInfo', {
            ...bookingInfo,
            primaryParticipant: {
                ...bookingInfo?.primaryParticipant,
                name,
            },
        });
    }
    setParticipantEmail(email) {
        const { bookingInfo } = this.schedulerStore.state;
        this.schedulerStore.set('bookingInfo', {
            ...bookingInfo,
            primaryParticipant: {
                ...bookingInfo?.primaryParticipant,
                email,
            },
        });
    }
    async resetStoreStateAndFetchAvailability() {
        const today = new Date();
        const startTime = new Date(today.getFullYear(), today.getMonth(), 1).getTime() / 1000;
        const endTime = new Date(today.getFullYear(), today.getMonth() + 1, 1).getTime() / 1000;
        const result = await this.getAvailability(startTime, endTime);
        const firstAvailableDate = this.schedulerStore.get('availability').find((timeslot) => new Date(timeslot.start_time) > new Date());
        let _selectedDate = today;
        if (firstAvailableDate) {
            _selectedDate = firstAvailableDate.start_time;
        }
        this.schedulerStore.set('selectedDate', _selectedDate);
        this.schedulerStore.set('eventInfo', null);
        this.schedulerStore.set('showBookingForm', false);
        this.schedulerStore.set('selectedTimeslot', null);
        return result;
    }
    async setReschedule(bookingID) {
        const result = await this.resetStoreStateAndFetchAvailability();
        this.schedulerStore.set('rescheduleBookingId', bookingID);
        return result;
    }
    async setCancel(bookingID) {
        this.schedulerStore.set('cancelBookingId', bookingID);
    }
    async resetCancel() {
        const result = await this.resetStoreStateAndFetchAvailability();
        this.schedulerStore.set('cancelBookingId', '');
        this.schedulerStore.set('cancelledEventInfo', null);
        return result;
    }
    async bookTimeslot(data) {
        this.schedulerStore.set('isLoading', true);
        const { selectedTimeslot, selectedTimezone, bookingInfo } = this.schedulerStore.state;
        if (!data && !bookingInfo) {
            return { error: this.errors.component('Booking').no_booking_info() };
        }
        const timeslot = data?.timeslot || selectedTimeslot;
        if (!timeslot) {
            return { error: this.errors.component('Create Booking').no_timeslot_selected() };
        }
        const timezone = data && data?.timezone ? data?.timezone : selectedTimezone;
        if (!timezone) {
            return { error: this.errors.component('Create Booking').no_timezone_selected() };
        }
        const primaryParticipant = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;
        const guests = data ? data?.guests || [] : bookingInfo?.guests || [];
        const additional_fields = data ? { ...data?.additionalFields, guests } : { ...bookingInfo?.additionalFields, guests };
        const headers = this.getHeaders();
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/bookings${configIdParam}`;
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'POST', JSON.stringify({
            additional_fields,
            guest: { ...primaryParticipant },
            start_time: timeslot.start_time.getTime() / 1000,
            end_time: timeslot.end_time.getTime() / 1000,
            timezone: timezone,
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Create Booking')) {
                error = this.errors.api('Create Booking')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        if ('data' in response) {
            this.schedulerStore.set('eventInfo', response?.data);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async getUISettings() {
        this.schedulerStore.set('isLoading', true);
        const headers = this.getHeaders();
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/ui-settings${configIdParam}`;
        const response = await this.makeAPIRequest(url, 'GET', undefined, headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Get UI Settings')) {
                error = this.errors.api('Get UI Settings')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        if ('data' in response) {
            this.schedulerStore.set('configSettings', response.data);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async getAvailability(startTime = 0, endTime = 0) {
        this.schedulerStore.set('isLoading', true);
        const params = new URLSearchParams();
        const now = new Date();
        const nowTime = now.getTime();
        if (endTime && endTime < nowTime / 1000) {
            this.schedulerStore.set('isLoading', false);
            const error = this.errors.component('Get Availability').endtime_not_in_future();
            return { error };
        }
        if (!startTime) {
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
            startTime = Math.floor(startOfMonth.getTime() / 1000);
        }
        if (!endTime) {
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            endTime = Math.floor(endOfMonth.getTime() / 1000);
        }
        params.append('start_time', encodeURIComponent(startTime.toString()));
        params.append('end_time', encodeURIComponent(endTime.toString()));
        if (this.configId) {
            params.append('configuration_id', encodeURIComponent(this.configId));
        }
        const queryString = params.toString();
        const url = `/v3/scheduling/availability${queryString ? `?${queryString}` : ''}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'GET', undefined, headers);
        if ('error' in response) {
            this.schedulerStore.set('availability', []);
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Get Availability')) {
                error = this.errors.api('Get Availability')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        if ('data' in response) {
            const availability = response.data?.time_slots?.map(timeslot => {
                return {
                    ...timeslot,
                    start_time: new Date(timeslot.start_time * 1000),
                    end_time: new Date(timeslot.end_time * 1000),
                };
            }) || [];
            const availabilityTimeslotsFiltered = availability.filter(timeslot => timeslot.start_time.getTime() > nowTime);
            this.schedulerStore.set('availability', availabilityTimeslotsFiltered);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async cancelBooking(bookingId) {
        this.schedulerStore.set('isLoading', true);
        if (!bookingId) {
            return { error: this.errors.component('Cancel Booking').no_booking_id() };
        }
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'DELETE', JSON.stringify({
            action: 'cancel',
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Cancel Booking')) {
                error = this.errors.api('Cancel Booking')[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        this.schedulerStore.set('cancelledEventInfo', {
            booking_id: bookingId,
        });
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async rescheduleBooking(bookingId, data) {
        this.schedulerStore.set('isLoading', true);
        if (!bookingId) {
            return { error: this.errors.component('Reschedule Booking').no_booking_id() };
        }
        const apiErrors = this.errors.api('Reschedule Booking');
        const componentErrors = this.errors.component('Reschedule Booking');
        const { bookingInfo, selectedTimeslot, selectedTimezone } = this.schedulerStore.state;
        const { startTime, endTime, timezone } = data;
        const start_time = startTime || selectedTimeslot?.start_time;
        if (!start_time) {
            return { error: componentErrors.invalid_start_time('Please pass "startTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
        }
        const end_time = endTime || selectedTimeslot?.end_time;
        if (!end_time) {
            return { error: componentErrors.invalid_end_time('Please pass "endTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
        }
        const time_zone = timezone || selectedTimezone;
        if (!time_zone) {
            return { error: componentErrors.invalid_timezone('Please pass "timezone" in data or set "selectedTimezone" in the defaultSchedulerState.') };
        }
        const primaryParticipant = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;
        const guests = data ? data?.guests || [] : bookingInfo?.guests || [];
        const additional_fields = data ? { ...data?.additionalFields, guests } : { ...bookingInfo?.additionalFields, guests };
        const configIdParam = this.configId ? `?configuration_id=${this.configId}` : '';
        const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'PATCH', JSON.stringify({
            start_time: start_time.getTime() / 1000,
            end_time: end_time.getTime() / 1000,
            time_zone,
            additional_fields,
            guest: { ...primaryParticipant },
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in apiErrors) {
                error = apiErrors[errorType](error?.message || error?.title || 'Something went wrong');
            }
        }
        if ('data' in response)
            this.schedulerStore.set('eventInfo', response?.data);
        this.schedulerStore.set('isLoading', false);
        return response;
    }
}
//# sourceMappingURL=scheduler.js.map
