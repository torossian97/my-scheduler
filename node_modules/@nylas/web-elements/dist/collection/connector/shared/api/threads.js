import { debug } from "../../../utils/utils";
import { NylasAPIError, isNylasErrorResponse } from "@nylas/core";
export class NylasThreadsConnector {
    constructor(nylasAuth, nylasAuthStore, nylasMailboxStore, router) {
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
        this.nylasMailboxStore = nylasMailboxStore;
        this.router = router;
    }
    async getThreads(overrideQueryParams, updateMethod = 'overwrite', updateState = true) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing thread:read-only scope');
        }
        if (updateState) {
            this.nylasMailboxStore.state.state = 'loading';
        }
        const queryParams = overrideQueryParams || this.nylasMailboxStore.state.threadsQueryParams;
        const params = new URLSearchParams();
        for (const key in queryParams) {
            const value = queryParams[key]?.toString();
            if (typeof value !== 'undefined' && value !== null) {
                params.append(key, value);
            }
        }
        if (queryParams.search_query_native) {
            this.router.navigate(`/?query=${queryParams.search_query_native}`, true);
        }
        else if (this.nylasMailboxStore.state.threadsQueryParams.search_query_native && !queryParams.search_query_native) {
            this.router.navigate('/', true);
        }
        if (!queryParams.page_token) {
            this.nylasMailboxStore.state.previousThreadPageTokens = [];
        }
        this.nylasMailboxStore.state.threadsQueryParams = queryParams;
        const path = `/v3/grants/me/threads?${params.toString()}`;
        const response = await this.nylasAuth.nylasAPIRequest(path);
        if (isNylasErrorResponse(response)) {
            throw new NylasAPIError(response.error);
        }
        const threads = response.data;
        switch (updateMethod) {
            case 'prepend':
                this.nylasMailboxStore.state.threads = [...threads, ...this.nylasMailboxStore.state.threads];
                break;
            case 'append':
                this.nylasMailboxStore.state.threads = [...this.nylasMailboxStore.state.threads, ...threads];
                break;
            case 'overwrite':
            default:
                this.nylasMailboxStore.state.threads = threads;
                break;
        }
        if (response.next_cursor) {
            this.nylasMailboxStore.state.nextThreadPageToken = response.next_cursor;
        }
        else {
            this.nylasMailboxStore.state.nextThreadPageToken = null;
        }
        if (updateState) {
            this.nylasMailboxStore.state.state = 'ready';
        }
        return threads;
    }
    async getThread(threadId) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {
            throw new Error('Missing thread:read-only scope');
        }
        const storeThread = this.nylasMailboxStore.state.threads.find(t => t.id === threadId);
        if (storeThread) {
            return storeThread;
        }
        this.nylasMailboxStore.state.state = 'loading';
        const path = `/v3/grants/me/threads/${threadId}`;
        const response = await this.nylasAuth.nylasAPIRequest(path);
        if (isNylasErrorResponse(response)) {
            throw new NylasAPIError(response.error);
        }
        const thread = response.data;
        this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {
            if (t.id === thread.id) {
                return thread;
            }
            return t;
        });
        this.nylasMailboxStore.state.state = 'ready';
        return thread;
    }
    async nextThreadPage(updateMethod = 'overwrite', updateLoadingState = true) {
        if (!this.nylasMailboxStore.state.nextThreadPageToken) {
            throw new Error('No next page token');
        }
        this.nylasMailboxStore.state.previousThreadPageTokens = Array.from(new Set([...this.nylasMailboxStore.state.previousThreadPageTokens, this.nylasMailboxStore.state.threadsQueryParams.page_token ?? null]));
        const nextPageToken = this.nylasMailboxStore.state.nextThreadPageToken;
        return this.getThreads({
            ...this.nylasMailboxStore.state.threadsQueryParams,
            page_token: nextPageToken,
        }, updateMethod, updateLoadingState);
    }
    async previousThreadPage(aupdateMethod = 'overwrite', updateLoadingState = true) {
        if (!this.nylasMailboxStore.state.previousThreadPageTokens.length) {
            throw new Error('No previous page token');
        }
        const previousThreadPageTokens = [...this.nylasMailboxStore.state.previousThreadPageTokens];
        const pageToken = previousThreadPageTokens.pop();
        this.nylasMailboxStore.state.previousThreadPageTokens = previousThreadPageTokens;
        return this.getThreads({
            ...this.nylasMailboxStore.state.threadsQueryParams,
            page_token: pageToken ?? undefined,
        }, aupdateMethod, updateLoadingState);
    }
    updateThreadQueryParams(params) {
        this.nylasMailboxStore.state.threadsQueryParams = {
            ...this.nylasMailboxStore.state.threadsQueryParams,
            ...params,
        };
    }
    back() {
        this.router.navigate('/', true);
        this.nylasMailboxStore.state.selectedThread = null;
    }
    unSelectThread() {
        this.nylasMailboxStore.state.selectedThread = null;
    }
    async selectThread(thread) {
        this.router.navigate(`/thread/${thread.id}`, true);
        this.nylasMailboxStore.state.selectedThread = thread;
        if (thread.unread) {
            this.markThreadAsRead(thread).catch(error => {
                debug('Error marking thread as read', error);
            });
        }
    }
    async markThreadAsRead(thread) {
        return this.updateThread(thread, { unread: false });
    }
    async updateThread(thread, updateThread) {
        if (!this.nylasAuthStore.state.isAuthenticated) {
            throw new Error('Not authenticated');
        }
        if (!this.nylasAuth.hasScopeByType('email', 'modify')) {
            throw new Error('Missing thread:modify scope');
        }
        const path = `/v3/grants/me/threads/${thread.id}`;
        const response = await this.nylasAuth.nylasAPIRequest(path, 'PUT', updateThread);
        if (isNylasErrorResponse(response)) {
            throw new NylasAPIError(response.error);
        }
        const updatedThread = response.data;
        this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {
            if (t.id === updatedThread.id) {
                return updatedThread;
            }
            return t;
        });
        this.nylasMailboxStore.state.selectedThread = updatedThread;
        return updatedThread;
    }
}
//# sourceMappingURL=threads.js.map
