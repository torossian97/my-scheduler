{"version":3,"file":"threads.js","sourceRoot":"","sources":["../../../../src/connector/shared/api/threads.ts"],"names":[],"mappings":"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","sourcesContent":["import { debug } from '@/utils/utils';\nimport { NylasAPIError, NylasAuthType, NylasResponse, Thread, ThreadQueryParameters, isNylasErrorResponse } from '@nylas/core';\nimport { NylasAuthStoreType, NylasMailboxStoreType } from '../../../components';\nimport { RouterInterface } from '@/routers/router-interface';\n\nexport class NylasThreadsConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n  private nylasMailboxStore: NylasMailboxStoreType;\n  private router: RouterInterface;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasMailboxStore: NylasMailboxStoreType, router: RouterInterface) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasMailboxStore = nylasMailboxStore;\n    this.router = router;\n  }\n\n  /**\n   * Returns the list of threads.\n   * @todo Re-think how we handle pagination (previous/next page tokens) - there is a separation of logic here that might be confusing.\n   * @param {Partial<ThreadQueryParameters> | undefined} overrideQueryParams The query parameters to override from the store.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateState Whether to update the state or not (default: true).\n   * @returns {Promise<Thread[]>}\n   */\n  public async getThreads(\n    overrideQueryParams?: Partial<ThreadQueryParameters>,\n    updateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite',\n    updateState: boolean = true,\n  ): Promise<Thread[]> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Set the state to loading.\n    if (updateState) {\n      this.nylasMailboxStore.state.state = 'loading';\n    }\n\n    // Build the URL with the query parameters\n    const queryParams = overrideQueryParams || this.nylasMailboxStore.state.threadsQueryParams;\n    const params = new URLSearchParams();\n    for (const key in queryParams) {\n      const value = queryParams[key as keyof typeof queryParams]?.toString();\n      if (typeof value !== 'undefined' && value !== null) {\n        params.append(key, value);\n      }\n    }\n\n    // TODO: Re-think how to update the router, this seems wrong\n    if (queryParams.search_query_native) {\n      this.router.navigate(`/?query=${queryParams.search_query_native}`, true);\n    } else if (this.nylasMailboxStore.state.threadsQueryParams.search_query_native && !queryParams.search_query_native) {\n      this.router.navigate('/', true);\n    }\n\n    // If page_token is not set, reset the previous page tokens.\n    if (!queryParams.page_token) {\n      this.nylasMailboxStore.state.previousThreadPageTokens = [];\n    }\n\n    this.nylasMailboxStore.state.threadsQueryParams = queryParams;\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads?${params.toString()}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread[]>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const threads = response.data;\n    switch (updateMethod) {\n      case 'prepend':\n        this.nylasMailboxStore.state.threads = [...threads, ...this.nylasMailboxStore.state.threads];\n        break;\n      case 'append':\n        this.nylasMailboxStore.state.threads = [...this.nylasMailboxStore.state.threads, ...threads];\n        break;\n      case 'overwrite':\n      default:\n        this.nylasMailboxStore.state.threads = threads;\n        break;\n    }\n\n    // If we have a next cursor, set it in the store.\n    if (response.next_cursor) {\n      this.nylasMailboxStore.state.nextThreadPageToken = response.next_cursor;\n    } else {\n      this.nylasMailboxStore.state.nextThreadPageToken = null;\n    }\n\n    // Set the state to ready.\n    if (updateState) {\n      this.nylasMailboxStore.state.state = 'ready';\n    }\n\n    return threads;\n  }\n\n  public async getThread(threadId: string): Promise<Thread> {\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a read-only or modify scopes\n    if (!this.nylasAuth.hasScopeByType('email', ['read-only', 'modify'])) {\n      throw new Error('Missing thread:read-only scope');\n    }\n\n    // Check if we have the thread in the store already.\n    const storeThread = this.nylasMailboxStore.state.threads.find(t => t.id === threadId);\n    if (storeThread) {\n      return storeThread;\n    }\n\n    // Set the state to loading.\n    this.nylasMailboxStore.state.state = 'loading';\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads/${threadId}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread>>(path);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Set the threads in the store.\n    const thread = response.data;\n    this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {\n      if (t.id === thread.id) {\n        return thread;\n      }\n      return t;\n    });\n\n    // Set the state to ready.\n    this.nylasMailboxStore.state.state = 'ready';\n\n    return thread;\n  }\n\n  /**\n   * Returns the next page of threads.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateLoadingState Whether to update the loading state or not.\n   * @returns {Promise<Thread[]>} The previous page of threads.\n   */\n  public async nextThreadPage(updateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite', updateLoadingState: boolean = true): Promise<Thread[]> {\n    if (!this.nylasMailboxStore.state.nextThreadPageToken) {\n      throw new Error('No next page token');\n    }\n\n    // If we have a next page token, add it to the previous page tokens.\n    this.nylasMailboxStore.state.previousThreadPageTokens = Array.from(\n      new Set([...this.nylasMailboxStore.state.previousThreadPageTokens, this.nylasMailboxStore.state.threadsQueryParams.page_token ?? null]),\n    );\n\n    // Get the last next page token.\n    const nextPageToken = this.nylasMailboxStore.state.nextThreadPageToken;\n\n    return this.getThreads(\n      {\n        ...this.nylasMailboxStore.state.threadsQueryParams,\n        page_token: nextPageToken,\n      },\n      updateMethod,\n      updateLoadingState,\n    );\n  }\n\n  /**\n   * Returns the previous page of threads.\n   * @param {'prepend' | 'append' | 'overwrite'} updateMethod How to update the store with the threads (default: overwrite).\n   * @param {boolean} updateLoadingState Whether to update the loading state or not.\n   * @returns {Promise<Thread[]>} The previous page of threads.\n   */\n  public async previousThreadPage(aupdateMethod: 'prepend' | 'append' | 'overwrite' = 'overwrite', updateLoadingState: boolean = true): Promise<Thread[]> {\n    if (!this.nylasMailboxStore.state.previousThreadPageTokens.length) {\n      throw new Error('No previous page token');\n    }\n\n    // Remove the the last two next page tokens.\n    const previousThreadPageTokens = [...this.nylasMailboxStore.state.previousThreadPageTokens];\n    const pageToken = previousThreadPageTokens.pop();\n\n    // Update the store.\n    this.nylasMailboxStore.state.previousThreadPageTokens = previousThreadPageTokens;\n\n    return this.getThreads(\n      {\n        ...this.nylasMailboxStore.state.threadsQueryParams,\n        page_token: pageToken ?? undefined,\n      },\n      aupdateMethod,\n      updateLoadingState,\n    );\n  }\n\n  /**\n   * Updates the thread query parameters in the store.\n   * @param params Partial<ThreadQueryParameters>\n   * @returns {void}\n   */\n  public updateThreadQueryParams(params: Partial<ThreadQueryParameters>): void {\n    this.nylasMailboxStore.state.threadsQueryParams = {\n      ...this.nylasMailboxStore.state.threadsQueryParams,\n      ...params,\n    };\n  }\n\n  /**\n   * Back to the mailbox.\n   */\n  public back(): void {\n    this.router.navigate('/', true);\n    this.nylasMailboxStore.state.selectedThread = null;\n  }\n\n  /**\n   * Unselects a thread.\n   */\n  public unSelectThread(): void {\n    this.nylasMailboxStore.state.selectedThread = null;\n  }\n\n  /**\n   * Selects a thread.\n   * @param {Thread} thread The thread to select.\n   * @returns {Promise<void>}\n   */\n  public async selectThread(thread: Thread): Promise<void> {\n    this.router.navigate(`/thread/${thread.id}`, true);\n    this.nylasMailboxStore.state.selectedThread = thread;\n\n    // Mark the thread as read (async) if it is unread.\n    if (thread.unread) {\n      this.markThreadAsRead(thread).catch(error => {\n        debug('Error marking thread as read', error);\n      });\n    }\n  }\n\n  /**\n   * Marks a thread as read.\n   * @param thread\n   * @returns {Promise<Thread>}\n   */\n  public async markThreadAsRead(thread: Thread): Promise<Thread> {\n    return this.updateThread(thread, { unread: false });\n  }\n\n  /**\n   * Updates a thread.\n   * @param thread The thread to update.\n   * @returns {Promise<Thread>}\n   */\n  public async updateThread(thread: Thread, updateThread: Partial<Thread>): Promise<Thread> {\n    // Make sure we have an authenticated user.\n    if (!this.nylasAuthStore.state.isAuthenticated) {\n      throw new Error('Not authenticated');\n    }\n\n    // Now make sure we have a modify scope at least.\n    if (!this.nylasAuth.hasScopeByType('email', 'modify')) {\n      throw new Error('Missing thread:modify scope');\n    }\n\n    // Make the API request.\n    const path = `/v3/grants/me/threads/${thread.id}`;\n    const response = await this.nylasAuth.nylasAPIRequest<NylasResponse<Thread>>(path, 'PUT', updateThread);\n    if (isNylasErrorResponse(response)) {\n      throw new NylasAPIError(response.error);\n    }\n\n    // Update the thread in the store.\n    const updatedThread = response.data;\n    this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map(t => {\n      if (t.id === updatedThread.id) {\n        return updatedThread;\n      }\n      return t;\n    });\n    this.nylasMailboxStore.state.selectedThread = updatedThread;\n\n    return updatedThread;\n  }\n}\n"]}