import { debug } from "../utils/utils";
export class PolyFillHashChangeEvent extends Event {
    constructor(type, eventInitDict) {
        super(type, eventInitDict);
        this.oldURL = eventInitDict.oldURL;
        this.newURL = eventInitDict.newURL;
    }
}
export class HashRouter {
    constructor() {
        this.routeChangeListeners = [];
        debug('HashRouter constructor');
    }
    destroy() {
        debug('HashRouter destroy');
        window.removeEventListener('hashchange', this.onRouteChange.bind(this));
    }
    init() {
        debug('HashRouter init');
        window.addEventListener('hashchange', this.onRouteChange.bind(this));
        if (typeof HashChangeEvent !== 'undefined') {
            const event = new HashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });
            this.onRouteChange(event);
        }
        else {
            const event = new PolyFillHashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });
            this.onRouteChange(event);
        }
    }
    addRouteChangeListener(route, listener) {
        debug('HashRouter addRouteChangeListener');
        this.routeChangeListeners.push([route, listener]);
    }
    navigate(route, shallow) {
        debug('HashRouter navigate');
        if (shallow) {
            return window.history.pushState(null, '', `#${route}`);
        }
        window.location.hash = route;
    }
    setRoute(route) {
        debug('HashRouter setRoute');
        window.location.hash = route;
    }
    matchRoute(route, path) {
        const routeParts = route.split('/');
        const pathParts = path.split('/');
        debug(`HashRouter matchRoute route=${route} path=${path}`, { routeParts, pathParts });
        if (routeParts[1] === '' && pathParts[0] === '') {
            return true;
        }
        if (routeParts.length !== pathParts.length) {
            return false;
        }
        for (let i = 0; i < routeParts.length; i++) {
            const routePart = routeParts[i];
            const pathPart = pathParts[i];
            if (routePart.startsWith(':')) {
                continue;
            }
            if (routePart !== pathPart) {
                return false;
            }
        }
        return true;
    }
    getRouteParams(route) {
        debug('HashRouter getRouteParams');
        const routeParams = {};
        const routeParts = route.split('/');
        const routeConfigParts = window.location.hash.split('/');
        routeParts.forEach((routePart, index) => {
            if (routePart.startsWith(':')) {
                const key = routePart.substring(1);
                routeParams[key] = routeConfigParts[index];
            }
        });
        return routeParams;
    }
    getRouteWithParams(route, routeParams) {
        debug('HashRouter getRouteWithParams');
        let routeWithParams = route;
        Object.keys(routeParams).forEach(key => {
            routeWithParams = routeWithParams.replace(`:${key}`, routeParams[key]);
        });
        return routeWithParams;
    }
    getRoute() {
        debug('HashRouter getRoute');
        return window.location.hash;
    }
    onRouteChange(event) {
        this.routeChangeListeners.forEach(async ([route, listener]) => {
            const path = event.newURL.indexOf('#') === -1 ? '' : event.newURL.substring(event.newURL.indexOf('#') + 1);
            debug(`HashRouter onRouteChange route=${route} path=${path}`, { event });
            if (!this.matchRoute(route, path)) {
                debug(`HashRouter onRouteChange route=${route} path=${path} does not match`);
                return;
            }
            const routeParams = this.getRouteParams(route);
            await listener(route, path, routeParams);
        });
    }
    getBasePath() {
        debug('HashRouter getBasePath');
        return '';
    }
}
//# sourceMappingURL=hash-router.js.map
