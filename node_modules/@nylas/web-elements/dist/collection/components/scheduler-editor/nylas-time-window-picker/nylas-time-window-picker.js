import { autocompleteTimeFormat, roundToNearest15Minutes, validateExactTimeFormat, validateTimeFormatInput } from "../../../utils/utils";
import { h, Host } from "@stencil/core";
import dayjs from "dayjs";
import customParseFormat from "dayjs/plugin/customParseFormat";
dayjs.extend(customParseFormat);
export class TimeInput {
    constructor() {
        this.time = undefined;
        this.minimumStartTime = null;
        this.placeholder = 'hh:mmam/pm';
        this.name = undefined;
        this.hasError = false;
        this.err = '';
        this.showTimes = false;
        this.ariaActivedescendant = '';
        this.times = this.generateTimes();
        this.shouldAutoScroll = false;
    }
    handleOutsideClick(event) {
        const path = event.composedPath();
        const isClickInside = path.includes(this.el);
        if (!isClickInside && this.showTimes) {
            this.showTimes = false;
        }
    }
    minimumStartTimeChangedHandler() {
        if (this.minimumStartTime) {
            let formattedTime = dayjs()
                .hour(parseInt(this.minimumStartTime))
                .minute(parseInt(this.minimumStartTime.slice(-4, -2)));
            if (this.minimumStartTime.slice(-2).toLowerCase() === 'pm' && parseInt(this.minimumStartTime) !== 12) {
                formattedTime = formattedTime.add(12, 'hour');
            }
            else if (this.minimumStartTime.slice(-2).toLowerCase() === 'am' && parseInt(this.minimumStartTime) === 12) {
                formattedTime = formattedTime.subtract(12, 'hour');
            }
            this.times = this.generateTimes();
            const firstTime = dayjs(this.times[0].value, 'hh:mma');
            let selectedTimeFormatted = dayjs(this.time, 'hh:mma');
            if (selectedTimeFormatted.isBefore(firstTime)) {
                this.err = 'Invalid';
                this.formError.emit({
                    key: this.el.id,
                    message: 'Invalid',
                });
            }
        }
    }
    componentDidRender() {
        if (this.showTimes && this.shouldAutoScroll) {
            const autocompletedTime = autocompleteTimeFormat(this.time);
            const optionIndex = this.times.findIndex(time => time.value === autocompletedTime);
            if (optionIndex > -1) {
                this.shouldAutoScroll = false;
                this.scrollToViewWithinParent(optionIndex);
            }
            return;
        }
    }
    handleTimeChange(_e, input) {
        const timePart = input.split(':');
        if (timePart[0] === '00' && timePart[1].slice(-2) == 'pm') {
            this.err = 'Invalid';
            this.formError.emit({
                key: this.el.id,
                message: 'Invalid',
            });
        }
        if (!validateTimeFormatInput(input)) {
            this.err = 'Invalid';
            this.formError.emit({
                key: this.el.id,
                message: 'Invalid',
            });
        }
        else {
            this.err = '';
            this.formError.emit({
                key: this.el.id,
                message: '',
            });
        }
        this.timeChange.emit({
            key: this.el.id,
            value: input,
        });
    }
    handleTimeAutocomplete(event) {
        const input = event.target?.value;
        if (!validateTimeFormatInput(input)) {
            this.err = 'Invalid';
            this.formError.emit({
                key: this.el.id,
                message: 'Invalid',
            });
            return;
        }
        if (input === '') {
            const newTime = roundToNearest15Minutes().format('hh:mma');
            this.timeChange.emit({
                key: this.el.id,
                value: newTime,
            });
            return;
        }
        if (!validateExactTimeFormat(input)) {
            const autocompletedTime = autocompleteTimeFormat(input);
            this.timeChange.emit({
                key: this.el.id,
                value: autocompletedTime,
            });
            return;
        }
        this.timeChange.emit({
            key: this.el.id,
            value: input,
        });
    }
    handleOnInput(event) {
        const input = event.target?.value;
        if (!validateTimeFormatInput(input)) {
            return;
        }
        if (input === '') {
            const newTime = roundToNearest15Minutes().format('hh:mma');
            const optionIndex = this.times.findIndex(time => time.value === newTime);
            if (optionIndex > -1) {
                this.scrollToViewWithinParent(optionIndex);
            }
            return;
        }
        if (!validateExactTimeFormat(input)) {
            const autocompletedTime = autocompleteTimeFormat(input);
            const optionIndex = this.times.findIndex(time => time.value === autocompletedTime);
            if (optionIndex > -1) {
                this.scrollToViewWithinParent(optionIndex);
            }
            return;
        }
    }
    generateTimes() {
        const times = [];
        let startTime = dayjs().set('hour', 0).set('minute', 0).set('second', 0);
        if (this.minimumStartTime) {
            startTime = dayjs(this.minimumStartTime, 'hh:mma');
        }
        const diff = startTime.endOf('day').diff(startTime, 'minutes');
        const iterations = Math.round(diff / 15);
        for (let i = 0; i < iterations + 1; i++) {
            const time = startTime.add(i * 15, 'minute');
            if (i == iterations && time.format('hh:mma').includes('am')) {
                break;
            }
            times.push({ id: i, value: time.format('hh:mma') });
        }
        return times;
    }
    handleComboboxKeyDown(event) {
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            if (!this.showTimes) {
                this.showTimes = true;
                this.shouldAutoScroll = true;
                return;
            }
            if (this.ariaActivedescendant === '') {
                this.ariaActivedescendant = this.times[0].id.toString();
                this.focusOption(0);
            }
            else {
                const currentIndex = this.times.findIndex(time => time.id.toString() === this.ariaActivedescendant);
                const nextIndex = currentIndex + 1 < this.times.length ? currentIndex + 1 : 0;
                this.ariaActivedescendant = this.times[nextIndex].id.toString();
                this.focusOption(nextIndex);
            }
        }
        else if (event.key === 'ArrowUp') {
            event.preventDefault();
            if (this.ariaActivedescendant === '') {
                this.ariaActivedescendant = this.times[this.times.length - 1].id.toString();
                this.focusOption(this.times.length - 1);
            }
            else {
                const currentIndex = this.times.findIndex(time => time.id.toString() === this.ariaActivedescendant);
                const prevIndex = currentIndex - 1 >= 0 ? currentIndex - 1 : this.times.length - 1;
                this.ariaActivedescendant = this.times[prevIndex].id.toString();
                this.focusOption(prevIndex);
            }
        }
        else if (event.key === 'Escape') {
            this.showTimes = false;
            this.timeInput.focus();
        }
    }
    handleListboxKeydown(e) {
        const items = this.times;
        const currentIndex = items.findIndex(item => item.id.toString() === this.ariaActivedescendant);
        if (e.key === 'ArrowDown' || (e.key === 'Tab' && !e.shiftKey)) {
            e.preventDefault();
            const nextIndex = currentIndex + 1 < items.length ? currentIndex + 1 : 0;
            this.ariaActivedescendant = items[nextIndex].id.toString();
            this.focusOption(nextIndex);
        }
        else if (e.key === 'ArrowUp' || (e.key === 'Tab' && e.shiftKey)) {
            e.preventDefault();
            const prevIndex = currentIndex - 1 >= 0 ? currentIndex - 1 : items.length - 1;
            this.ariaActivedescendant = items[prevIndex].id.toString();
            this.focusOption(prevIndex);
        }
        else if (e.key === 'Enter') {
            e.preventDefault();
            if (this.ariaActivedescendant) {
                const option = items[currentIndex];
                this.handleTimeChange(e, option.value);
                this.showTimes = false;
                this.ariaActivedescendant = '';
                this.timeInput.focus();
            }
        }
        else if (e.key === 'Escape') {
            this.showTimes = false;
            this.timeInput.focus();
        }
    }
    scrollToViewWithinParent(optionIndex) {
        const option = this.times[optionIndex];
        const childElement = this.el.shadowRoot?.getElementById(option.id.toString());
        const parentElement = this.timeMenu;
        this.ariaActivedescendant = option.id.toString();
        const childRect = childElement.getBoundingClientRect();
        const parentRect = parentElement.getBoundingClientRect();
        if (childRect.top < parentRect.top) {
            parentElement.scrollTop -= parentRect.top - childRect.top;
        }
        else if (childRect.bottom > parentRect.bottom) {
            parentElement.scrollTop += childRect.bottom - parentRect.bottom;
        }
        if (childRect.left < parentRect.left) {
            parentElement.scrollLeft -= parentRect.left - childRect.left;
        }
        else if (childRect.right > parentRect.right) {
            parentElement.scrollLeft += childRect.right - parentRect.right;
        }
    }
    focusOption(index) {
        const option = this.times[index];
        if (!option)
            return;
        const elementId = option.id.toString();
        const element = this.el.shadowRoot?.getElementById(elementId);
        if (element) {
            element.focus();
            element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }
    render() {
        return (h(Host, { key: '4a03bc9829bace5ed02129d99e12b6042f49386c' }, h("div", { key: 'ccc660e6cd8727226b7418ee20fe700812f7c70b', class: "time-picker", part: "time-picker" }, h("input", { key: '24be2b42322194545575045f5624ac78bf8c643e', type: "text", name: this.name, id: this.name, part: "time-input", class: {
                'time-input': true,
                'error': !!this.err || this.hasError,
            }, ref: el => (this.timeInput = el), value: this.time, onClick: () => {
                this.showTimes = true;
                this.shouldAutoScroll = true;
            }, "aria-haspopup": "listbox", "aria-label": this.name, "aria-expanded": this.showTimes ? 'true' : 'false', placeholder: this.placeholder, onKeyDown: e => this.handleComboboxKeyDown(e), onInput: event => this.handleOnInput(event), onBlur: event => this.handleTimeAutocomplete(event) }), this.err && h("div", { class: "invalid-time-icon" }), this.showTimes && (h("div", { class: "times", part: "times", ref: el => (this.timeMenu = el) }, h("ul", { tabindex: "-1", role: "listbox", "aria-label": this.name, "aria-activedescendant": this.ariaActivedescendant, onKeyDown: e => this.handleListboxKeydown(e) }, this.times.map(option => (h("li", { tabindex: "0", key: option.id, id: option.id.toString(), class: {
                focused: this.ariaActivedescendant === option.id.toString(),
            }, onClick: e => {
                this.handleTimeChange(e, option.value);
                this.showTimes = false;
                this.timeInput.focus();
            }, role: "option" }, `${option.value}`)))))), !this.showTimes && this.err && (h("p", { class: "error", id: "email-error" }, this.err)))));
    }
    static get is() { return "nylas-time-window-picker"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["nylas-time-window-picker.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["nylas-time-window-picker.css"]
        };
    }
    static get properties() {
        return {
            "time": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": true,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The time to display in the input.\nThis is passed by the parent component and can be updated\nusing the setTime prop function provided by the parent component."
                },
                "attribute": "time",
                "reflect": false
            },
            "minimumStartTime": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string | null",
                    "resolved": "null | string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "This is the start time value if one is set by the parent component.\nIt is useful if this component is used to render an end time which\nshould not be before the start time, defining the earliest selectable time."
                },
                "attribute": "minimum-start-time",
                "reflect": false,
                "defaultValue": "null"
            },
            "placeholder": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The placeholder text for the input."
                },
                "attribute": "placeholder",
                "reflect": false,
                "defaultValue": "'hh:mmam/pm'"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": true,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The name of the input."
                },
                "attribute": "name",
                "reflect": false
            },
            "hasError": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "This sets the error state of the input."
                },
                "attribute": "has-error",
                "reflect": false,
                "defaultValue": "false"
            }
        };
    }
    static get states() {
        return {
            "err": {},
            "showTimes": {},
            "ariaActivedescendant": {},
            "times": {},
            "shouldAutoScroll": {}
        };
    }
    static get events() {
        return [{
                "method": "timeChange",
                "name": "timeChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the time is changed."
                },
                "complexType": {
                    "original": "{\n    key: string;\n    value: string;\n  }",
                    "resolved": "{ key: string; value: string; }",
                    "references": {}
                }
            }, {
                "method": "formError",
                "name": "formError",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the form has an error. The parent component\ncan listen for this event and display an error message or set form validity."
                },
                "complexType": {
                    "original": "{\n    key: string;\n    message: string;\n  }",
                    "resolved": "{ key: string; message: string; }",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "minimumStartTime",
                "methodName": "minimumStartTimeChangedHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "click",
                "method": "handleOutsideClick",
                "target": "document",
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=nylas-time-window-picker.js.map
