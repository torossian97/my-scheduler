var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
import { RegisterComponent } from "../../../common/register-component";
import { debug, getBrowser, isNonPrintableKey } from "../../../utils/utils";
import { Host, h } from "@stencil/core";
import { EVENT_TITLE_TOKENS as eventTitleTokens } from "../../../common/constants";
export class NylasEventTitle {
    constructor() {
        this.selectedConfiguration = undefined;
        this.eventTitle = this.selectedConfiguration?.event_booking?.title;
        this.name = 'title';
        this.showTokens = false;
        this.availableTokens = eventTitleTokens.map(token => ({
            label: token.token,
            value: token.value,
            labelHTML: token,
        }));
        this.filteredTokens = this.availableTokens;
        this.ariaActivedescendant = '';
        this.currentWord = { $value: '', fullText: '', index: -1, focusOffset: -1 };
        this.validationError = '';
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-event-title', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    ariaActivedescendantChangedHandler(newValue) {
        debug('nylas-event-title', 'ariaActivedescendantChangedHandler', newValue);
        if (newValue !== '') {
            const activeOption = this.host.shadowRoot?.getElementById(newValue);
            activeOption?.classList.add('active');
        }
        else {
            const options = this.host.shadowRoot?.querySelectorAll('.token-options li.active');
            options?.forEach(option => option.classList.remove('active'));
        }
    }
    configChangedHandler(newVal) {
        const title = newVal?.event_booking?.title;
        if (title) {
            this.updateEventTitleFromProp(title);
        }
    }
    connectedCallback() {
        debug('nylas-event-title', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-title', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-event-title', 'componentDidLoad');
        this.updateEventTitleFromProp(this.eventTitle || '');
    }
    disconnectedCallback() {
        debug('nylas-event-title', 'disconnectedCallback');
    }
    formSubmittedHandler(event) {
        debug('nylas-event-title', 'formSubmittedHandler', event);
        if (!this.internals?.validity?.valid) {
            this.validationError = 'Event title is required';
        }
        else {
            this.validationError = '';
        }
    }
    updateEventTitleFromProp(newValue) {
        debug('nylas-event-title', 'eventTitleChangedHandler', newValue);
        if (this.titleRef) {
            this.titleRef.innerHTML = this.highlightTokens(newValue);
            this.titleRef.focus();
            if (typeof this.internals.setValidity === 'function') {
                if (newValue === '') {
                    this.internals?.setValidity({ customError: true }, `Event title is required`, this.titleRef);
                }
                else {
                    this.internals?.setValidity({ customError: false });
                }
            }
        }
    }
    highlightTokens(title) {
        let outputHtml = title;
        eventTitleTokens.forEach(tokenObj => {
            const token = tokenObj.value;
            const regex = new RegExp(`(\\${token})(?!\\w)`, 'g');
            outputHtml = outputHtml.replace(regex, '<span class="highlighted-tag">$1</span>');
        });
        return outputHtml;
    }
    getCurrentSelectionForBrowser() {
        const getSelectionTextData = (nodeValue, offset, node, allSelected) => {
            const text = nodeValue.replace(/[\u200B-\u200D\uFEFF]/g, '');
            const dollarIndex = text.lastIndexOf('$');
            const lastWord = text.substring(dollarIndex).split(' ')[0];
            return {
                focusOffset: offset,
                dollarIndex,
                lastWord,
                currentText: text,
                node,
                allSelected,
            };
        };
        const isAllSelected = (selection) => selection.anchorOffset === 0 && selection.focusOffset === selection.focusNode?.nodeValue?.length;
        const currentBrowser = getBrowser();
        switch (currentBrowser) {
            case 'Chrome':
                const shadowRootSelection = this.host.shadowRoot?.getSelection();
                const focusNode = shadowRootSelection?.focusNode;
                const focusNodeValue = focusNode?.nodeValue || '';
                const allSelected = shadowRootSelection && isAllSelected(shadowRootSelection);
                return getSelectionTextData(focusNodeValue, shadowRootSelection?.focusOffset || -1, focusNode, allSelected);
            case 'Firefox':
                const selection = document.getSelection();
                const anchorNodeValue = selection?.anchorNode?.nodeValue || '';
                const allSelectedFirefox = selection && isAllSelected(selection);
                return getSelectionTextData(anchorNodeValue, selection?.focusOffset || -1, selection?.anchorNode, allSelectedFirefox);
            case 'Safari':
                const windowSelection = window.getSelection();
                const anchorNode = windowSelection?.getComposedRanges(this.host.shadowRoot)[0];
                const currentText = anchorNode?.startContainer?.nodeValue || '';
                const allSelectedSafari = windowSelection && isAllSelected(windowSelection);
                return getSelectionTextData(currentText, anchorNode?.endOffset || -1, anchorNode?.startContainer, allSelectedSafari);
            default:
                console.warn('Browser not supported');
                return null;
        }
    }
    handleChange(event) {
        const textContent = event.target.textContent || '';
        const currentSelection = this.getCurrentSelectionForBrowser();
        if (!currentSelection) {
            this.updateEventTitle(textContent);
            this.resetDropdown();
            return;
        }
        const { focusOffset, dollarIndex, lastWord, currentText } = currentSelection;
        if (dollarIndex === -1 || focusOffset < dollarIndex) {
            this.updateEventTitle(textContent);
            this.resetDropdown();
            return;
        }
        if (lastWord.startsWith('$')) {
            this.showTokens = true;
            this.currentWord = {
                $value: lastWord,
                fullText: currentText,
                index: dollarIndex,
                focusOffset,
            };
            this.populateSuggestionsDropdown(lastWord);
        }
        else {
            this.resetDropdown();
        }
        this.updateEventTitle(textContent);
    }
    handleInputKeyDown(event) {
        const selection = this.getCurrentSelectionForBrowser();
        if (selection?.allSelected && !isNonPrintableKey(event)) {
            this.titleRef.innerHTML = '';
        }
        if (event.key === 'Enter') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                activeOption.click();
                this.ariaActivedescendant = '';
            }
        }
        else if (event.key === 'ArrowDown') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const nextOption = activeOption.nextElementSibling;
                if (nextOption) {
                    this.ariaActivedescendant = nextOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[0].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[0].label;
            }
        }
        else if (event.key === 'ArrowUp') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const prevOption = activeOption.previousElementSibling;
                if (prevOption) {
                    this.ariaActivedescendant = prevOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
            }
        }
        else if (event.key === 'Escape') {
            event.preventDefault();
            this.resetDropdown();
        }
        else if (event.key === 'Backspace' || event.key === 'Delete') {
            if (selection?.currentText.startsWith('${')) {
                selection?.node?.parentNode && selection.node.parentNode.removeChild(selection.node);
            }
            if (this.titleRef.textContent === '' || selection?.currentText === '' || selection?.allSelected) {
                this.titleRef.innerHTML = '';
            }
        }
    }
    selectOption(e, option) {
        e.preventDefault();
        const word = this.currentWord.fullText;
        const dollarWord = this.currentWord.$value;
        let currentNode = this.titleRef.firstChild;
        let textNode = null;
        while (currentNode) {
            if (currentNode.nodeType === 3) {
                const currentNodeText = currentNode.textContent?.replace(/[\u200B-\u200D\uFEFF]/g, '') || '';
                const wordText = word.replace(/[\u200B-\u200D\uFEFF]/g, '');
                if (currentNodeText.includes(wordText)) {
                    textNode = currentNode;
                    break;
                }
            }
            currentNode = currentNode.nextSibling;
        }
        if (!textNode) {
            return;
        }
        const text = textNode.textContent || '';
        const index = text.indexOf(dollarWord);
        const textBefore = text.substring(0, index);
        const textAfter = text.substring(index + dollarWord.length);
        const newTextNode = document.createTextNode(textBefore);
        const newRange = document.createRange();
        const tagSpan = document.createElement('span');
        tagSpan.classList.add('highlighted-tag');
        tagSpan.textContent = `${option.value}`;
        const newTextNodeAfter = document.createTextNode(textAfter);
        if (textAfter !== '') {
            textNode.replaceWith(newTextNode, tagSpan, newTextNodeAfter);
            newRange.setStart(newTextNodeAfter, 1);
        }
        else {
            const afterNode = document.createTextNode('\u200B');
            textNode.replaceWith(newTextNode, tagSpan, afterNode);
            newRange.setStart(afterNode, 1);
        }
        this.resetDropdown();
        this.titleRef.focus();
        const sel = window.getSelection();
        newRange.collapse(true);
        sel?.removeAllRanges();
        sel?.addRange(newRange);
        this.updateEventTitle(this.titleRef.textContent || '');
    }
    populateSuggestionsDropdown(query = '') {
        this.filteredTokens = this.availableTokens.filter(obj => {
            return obj.label.startsWith(query.toString()) || obj.value.startsWith(query.toString());
        });
        if (this.filteredTokens.length > 0) {
            this.ariaActivedescendant = this.filteredTokens[0].label;
        }
    }
    updateEventTitle(text) {
        const value = text.replace(/ +/g, ' ');
        if (value === '') {
            this.internals?.setValidity({ customError: true }, `Event title is required`, this.titleRef);
            this.validationError = 'Event title is required';
        }
        else {
            this.internals?.setValidity({ customError: false });
            this.validationError = '';
        }
        this.internals?.setFormValue(value, this.name);
        this.valueChanged.emit({ value: value, name: this.name });
    }
    resetDropdown() {
        this.showTokens = false;
        this.ariaActivedescendant = '';
    }
    getLabelHTML(token) {
        return (h("div", { class: "token-label" }, h("span", { class: "token" }, token.token), h("span", { class: "description" }, token.description)));
    }
    render() {
        return (h(Host, { key: '28ef0be3f64aafdaabb6bed562f5c89b92f2510e' }, h("div", { key: '42cc820bd4ca2343ebe09108a7ce5fca37c02165', class: "nylas-event-title", part: "net" }, h("label", { key: '748c85b9ef6a656b43137864c49282abfa0b78b9', htmlFor: "title" }, "Event title", h("span", { key: '29e8a26acfc6795ee511457c1f052bcc831757c3', class: "required" }, "*"), h("span", { key: 'a555e59986cb55543c108d82c9e7120e8f78cd2a', class: "label-icon" }, h("tooltip-component", { key: '29e6f432f02f6cb10bee3a3c61374688a23c9a9a' }, h("info-icon", { key: 'af9821938dc7f3175d8fdfb3426631111242483b', slot: "tooltip-icon" }), h("span", { key: 'b1027c6b32fab643f94c4233f3c60e1462f69945', slot: "tooltip-content" }, "Enter a title for your event.")))), h("div", { key: '387e621aa40cef2857b00eae8da13be376296178', class: {
                title: true,
                error: this.validationError !== '',
            }, part: "net__title", ref: el => (this.titleRef = el), contentEditable: "true", onInput: e => this.handleChange(e), onKeyDown: event => this.handleInputKeyDown(event) }), this.showTokens && this.filteredTokens?.length > 0 && (h("div", { class: "token-options", part: "net__dropdown-content" }, h("ul", { tabindex: "-1", role: "listbox", "aria-label": this.name, "aria-activedescendant": this.ariaActivedescendant }, this.filteredTokens.map(option => (h("li", { tabindex: "0", key: option.label, id: option.label, class: { active: this.ariaActivedescendant === option.label }, onClick: e => this.selectOption(e, option), role: "option" }, this.getLabelHTML(option.labelHTML))))))), h("span", { key: 'c1a3f0602920e0799322aef007e738ec3fd2c478', class: "help-text" }, "Create a dynamic templated event title by typing $. Learn more"), this.validationError != '' && h("span", { class: "error-message" }, this.validationError))));
    }
    static get is() { return "nylas-event-title"; }
    static get encapsulation() { return "shadow"; }
    static get formAssociated() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["nylas-event-title.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["nylas-event-title.css"]
        };
    }
    static get properties() {
        return {
            "selectedConfiguration": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Configuration",
                    "resolved": "Configuration | undefined",
                    "references": {
                        "Configuration": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::Configuration"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The selected config"
                }
            },
            "eventTitle": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The title of the event from the cofiguration."
                },
                "attribute": "event-title",
                "reflect": false,
                "defaultValue": "this.selectedConfiguration?.event_booking?.title"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The name attribute of this component."
                },
                "attribute": "name",
                "reflect": false,
                "defaultValue": "'title'"
            }
        };
    }
    static get states() {
        return {
            "showTokens": {},
            "availableTokens": {},
            "filteredTokens": {},
            "ariaActivedescendant": {},
            "currentWord": {},
            "validationError": {}
        };
    }
    static get events() {
        return [{
                "method": "valueChanged",
                "name": "valueChanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the value of the event title changes."
                },
                "complexType": {
                    "original": "{\n    value: string;\n    name: string;\n  }",
                    "resolved": "{ value: string; name: string; }",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "host"; }
    static get watchers() {
        return [{
                "propName": "name",
                "methodName": "elementNameChangedHandler"
            }, {
                "propName": "ariaActivedescendant",
                "methodName": "ariaActivedescendantChangedHandler"
            }, {
                "propName": "selectedConfiguration",
                "methodName": "configChangedHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "formSubmitted",
                "method": "formSubmittedHandler",
                "target": "window",
                "capture": false,
                "passive": false
            }];
    }
    static get attachInternalsMemberName() { return "internals"; }
}
__decorate([
    RegisterComponent({
        name: 'nylas-event-title',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NylasEventTitle.prototype, "render", null);
//# sourceMappingURL=nylas-event-title.js.map
