{"version":3,"file":"abstract-provider.js","sourceRoot":"","sources":["../../src/common/abstract-provider.ts"],"names":[],"mappings":"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","sourcesContent":["import { RegisteredComponent } from '@/common/register-component';\nimport { BaseNylasConnectorInterface } from '@/connector/connector-interface';\nimport { debug, formatEventName, uniqueID } from '@/utils/utils';\nimport { ObservableMap } from '@stencil/store';\nimport { EventOverride } from './component-types';\n\nexport type PropKey = string | number | symbol;\nexport type StoreKey = string;\nexport type StoreName<T> = keyof T;\nexport type StateKey = string;\nexport type ElementID = string;\nexport type PropStateRegistration = { elementId: ElementID; propKey: PropKey };\nexport type EventListenerRegistration = [HTMLElement, PropKey, (event: CustomEvent<any>) => Promise<void>];\n\nexport interface NylasProviderInterface<Stores extends Record<string, ObservableMap<any>>> {\n  nylasConnector?: BaseNylasConnectorInterface;\n  stores: Stores;\n  host?: HTMLElement;\n  automaticComponentRegistration: boolean;\n  registeredComponents: Record<ElementID, RegisteredComponent<any, any>>;\n  propStateRegistrations: Map<StoreName<this['stores']>, Map<StateKey, PropStateRegistration[]>>;\n  eventListenerRegistrations: Map<ElementID, EventListenerRegistration[]>;\n  componentWillLoad(nylasConnector: BaseNylasConnectorInterface): Promise<void>;\n  componentDidLoad(): Promise<void>;\n  componentDisconnected(): Promise<void>;\n  getStore<K extends keyof ThisType<this['stores']>>(name: K): ThisType<this['stores']>[K];\n  registerComponent(component: RegisteredComponent<any, any>): void;\n  unregisterComponent(component: RegisteredComponent<any, any>): void;\n}\n\nexport abstract class NylasAbstractProvider<Stores extends Record<string, ObservableMap<any>>> implements NylasProviderInterface<Stores> {\n  /**\n   * The NylasConnector instance.\n   * This is used to provide access to the NylasConnector instance to all components.\n   */\n  public nylasConnector?: BaseNylasConnectorInterface;\n\n  /**\n   * A list of stores that are used by the provider.\n   * This is used to provide access to the stores to all components.\n   */\n  public stores: Stores;\n\n  /**\n   * The host element.\n   * Used to manage the host element of the provider.\n   */\n  public host!: HTMLElement;\n\n  /**\n   * Automatically register components that have the `@RegisterComponent` decorator.\n   * If this is set to false, you will need to manually register components using the\n   * `registerComponent` method.\n   * @default true\n   */\n  public automaticComponentRegistration: boolean = true;\n\n  /**\n   * A list of registered components that are listening for store changes.\n   * Each component is registered with a unique id so that we can easily track the component\n   * for various other operations (see `propStateRegistrations` and `eventListenerRegistrations`).\n   */\n  public registeredComponents: Record<ElementID, RegisteredComponent<any, any>> = {};\n\n  /**\n   * A list of registered components that are listening for store changes.\n   * To make lookups more efficient, we use a Map of our prop registrations that we need to map to differnet\n   * state keys. When a component is unregistered, we can use this map to remove the prop registration.\n   */\n  public propStateRegistrations: Map<StoreName<this['stores']>, Map<StateKey, PropStateRegistration[]>> = new Map();\n\n  /**\n   * A list of registered event listeners.\n   * To make lookups more efficient, we use a Map of our event listeners that we need to map to differnet\n   * nylas connector methods. When a component is unregistered, we can use this map to remove the event listener.\n   */\n  public eventListenerRegistrations: Map<ElementID, EventListenerRegistration[]> = new Map();\n\n  /**\n   * A list of event overrides that are used by the provider.\n   * This is used to provide an easy way to override the default function of the event emitter.\n   * An example of this is the `timeslotConfirmed` event. By default, this event will set the scheduler store state for `showBookingForm` to `true` which will\n   * show the booking form. However, if you want to override this behavior, you can pass in the prop `eventOverride` like:\n   * ```html\n   * <nylas-scheduler eventOverride={{\"timeslotConfirmed\": (event, nylasConnector) => { console.log(\"Timeslot confirmed event fired!\"); } }} />\n   * ```\n   */\n  public eventOverrides: EventOverride<Exclude<typeof this.nylasConnector, undefined>>;\n\n  /**\n   * The constructor for the AbstractNylasProvider.\n   * @param host  The host element (usually the HTMLElement of the provider)\n   * @param stores A list of stores that are used by the provider\n   * @param automaticComponentRegistration A boolean that determines if components should be automatically registered\n   * @param eventOverrides A list of event overrides that are used by the provider\n   */\n  constructor(host: HTMLElement, stores: Stores, automaticComponentRegistration: boolean = true, eventOverrides: EventOverride<any>) {\n    this.host = host;\n    this.stores = stores;\n    this.automaticComponentRegistration = automaticComponentRegistration;\n    this.eventOverrides = eventOverrides;\n\n    debug(`[${this.hostTagName}] Initializing (abstract) provider.`, { eventOverrides });\n\n    this.registerComponent = this.registerComponent.bind(this);\n    this.getStore = this.getStore.bind(this);\n\n    // Init propStateRegistrations with store names\n    Object.keys(this.stores).forEach(storeName => {\n      this.propStateRegistrations.set(storeName, new Map());\n    });\n  }\n\n  /**\n   * This method is called before the component is loaded.\n   * We're passing the NylasConnector instance to the provider so that we can\n   * provide access to the NylasConnector instance to all components.\n   *\n   * However, because the NylasConnector is often constructed after the component's\n   * constructor is called, set the NylasConnector instance here.\n   * @param nylasConnector The NylasConnector instance\n   */\n  async componentWillLoad(nylasConnector: BaseNylasConnectorInterface) {\n    debug(`[${this.hostTagName}] Will load`);\n\n    // For each of our stores, configure the listeners for changes in the\n    // store state.\n    this.setupStoreListeners();\n\n    // Set the NylasConnector instance\n    this.nylasConnector = nylasConnector;\n\n    /**\n     * TODO: Pooja and Levon, please revisit this registration method. See if we can optimize or get rid of it\n     * completely.\n     *\n     * This is a very static way of registering components, but it happens fairly\n     * early in the component lifecycle, so it can be beneficial to do it here.\n     *\n     * The big downside to this is that it will not pick up any components that\n     * are dynamically added to the DOM after this method is called.\n     *\n     * So we should evaluate if this is the best way to register components.\n     */\n    const childComponents = Array.from(this.host.querySelectorAll('*')).filter(child => child.tagName.toLowerCase().startsWith('nylas-'));\n    debug(`[${this.hostTagName}] Found ${childComponents.length} child component(s).`, { childComponents });\n\n    childComponents.forEach(child => {\n      const component = child as any; // It unfortunately makes life a whole lot easier to just cast this to any\n      if (!component) {\n        debug(`[~${this.hostTagName}] Component ${component.tagName} does not have a name. Skipping.`);\n        return;\n      }\n\n      // Skip components that don't have the `registerNylasComponent` prop\n      if (!component.registerNylasComponent) {\n        debug(`[~${this.hostTagName}] Component ${component.tagName} is not a component that can be registered. Skipping.`, { component });\n        return;\n      }\n\n      const registeredComponent: RegisteredComponent<any, any> = {\n        element: component as HTMLElement,\n        name: component.tagName.toLowerCase(),\n        getStoresToProp: component.getStoresToProp,\n        storeToProps: component.storeToProps,\n        stateToProps: component.stateToProps,\n        authToProp: component.authToProp,\n        eventToProps: component.eventToProps,\n        connectorToProp: component.connectorToProp,\n        localPropsToProp: component.localPropsToProp,\n      };\n\n      this.registerComponent(registeredComponent);\n    });\n  }\n\n  /**\n   * This method is called after the component is loaded.\n   * We're using this method to add event listeners to the host element.\n   */\n  async componentDidLoad() {\n    debug(`[${this.hostTagName}] Did load`);\n  }\n\n  /**\n   * This method is called when the component is disconnected from the DOM.\n   * We're using this method to dispose of the stores.\n   */\n  async componentDisconnected() {\n    // Loop through each store and and dispose\n    Object.values(this.stores).forEach(store => {\n      store.dispose();\n    });\n  }\n\n  /**\n   * This is a custom event handler that is used to register a component with the provider.\n   * It is used by components that have the `@RegisterComponent` decorator.\n   * @param event A custom event that contains the component to register\n   * @returns Promise<void>\n   */\n  async registerComponentHandler(event: CustomEvent<RegisteredComponent<any, any>>): Promise<void> {\n    event.stopPropagation();\n\n    if (!this.automaticComponentRegistration) {\n      debug(`[${this.hostTagName}] Automatic component registration disabled. Skipping registration of ${event.detail.name}.`);\n      return;\n    }\n\n    this.registerComponent(event.detail);\n  }\n\n  /**\n   * This is a custom event handler that is used to unregister a component with the provider.\n   * It is used by components that have the `@RegisterComponent` decorator.\n   * @param event A custom event that contains the component to unregister\n   * @returns Promise<void>\n   */\n  async unregisterComponentHandler(event: CustomEvent<RegisteredComponent<any, any>>): Promise<void> {\n    event.stopPropagation();\n\n    if (!this.automaticComponentRegistration) {\n      debug(`[${this.hostTagName}] Automatic component registration disabled. Skipping unregistration of ${event.detail.name}.`);\n      return;\n    }\n\n    this.unregisterComponent(event.detail);\n  }\n\n  /**\n   * This method is used to register a component with the provider\n   * @param component component to register\n   * @returns void\n   */\n  public registerComponent(component: RegisteredComponent<any, any>): void {\n    debug(`[${this.hostTagName}] Registering component ${component.name}.`);\n\n    // Get component element id\n    const elementId = component.element.dataset.nylasId;\n\n    // Make sure the component is not already registered\n    if (elementId && this.registeredComponents[elementId]) {\n      debug(`[${this.hostTagName}] Component ${component.name} already registered. Skipping.`);\n      return;\n    }\n    const { stateToProps, getStoresToProp, eventToProps, storeToProps, connectorToProp, localPropsToProp, element } = component;\n\n    // Set a unique data id on the element so we can track it. We set this on the element\n    // so that we can easily find the element later.\n    element.dataset.nylasId = uniqueID();\n\n    // Register the component\n    this.registeredComponents[element.dataset.nylasId] = component;\n\n    const eventOverrides = this.eventOverrides;\n\n    /**\n     * We allow components to map an event to a prop. These events can automatically\n     * call a method on the nylasConnector instance.\n     */\n    eventToProps?.forEach((customEventHandler, propKey) => {\n      const nylasConnector = this.nylasConnector;\n      const handler = async (event: CustomEvent<any>) => {\n        debug(`[${this.hostTagName}] Handling \"${component.name}\" prop \"${String(propKey)}\" event.`, { event });\n        if (propKey in eventOverrides) {\n          debug(`[${this.hostTagName}] Found event override for \"${String(propKey)}\" event. Calling override.`);\n          await eventOverrides[propKey](event, nylasConnector);\n        }\n\n        if (!event.defaultPrevented) {\n          await customEventHandler(event, nylasConnector);\n        }\n\n        return;\n      };\n\n      const elementId = component.element.dataset.nylasId;\n\n      if (elementId && !this.eventListenerRegistrations.has(elementId)) {\n        this.eventListenerRegistrations.set(elementId, []);\n      }\n\n      if (elementId) {\n        this.eventListenerRegistrations.get(elementId)?.push([element, propKey, handler]);\n      }\n\n      debug(`[${this.hostTagName}] Setting \"${component.name}\" event \"${String(propKey)}\" to automcially call NylasConnector method.`);\n\n      // We should immediately call the event handler to make sure the prop is set\n      const eventName = formatEventName(propKey.toString());\n      debug(`[${this.hostTagName}] Adding event listener for \"${eventName}\" on \"${element.tagName}\"`);\n      element.addEventListener(eventName, handler as unknown as EventListener);\n    });\n\n    /**\n     * This is a rather simple way for us to set the initial props for a component.\n     * For each prop, we check if the prop is mapped to a store. If it is, we set\n     * the prop to the store value.\n     */\n    stateToProps?.forEach((propKey, stateKey) => {\n      const [storeName, stateName] = stateKey.split('.');\n      const store = this.getStore(storeName as keyof typeof this.stores);\n      const stateValue = store.state[stateName as keyof typeof store.state];\n\n      // Make sure this component was registered and has a nylasId\n      if (!element.dataset.nylasId) {\n        debug(`[${this.hostTagName}] Component \"${component.name}\" not registered. Skipping.`, { component });\n        return;\n      }\n\n      // We need to keep track of the store and prop key so that we can update the\n      // prop when the store changes\n      if (!this.propStateRegistrations.has(storeName as keyof typeof this.stores)) {\n        this.propStateRegistrations.set(storeName as keyof typeof this.stores, new Map());\n      }\n\n      if (!this.propStateRegistrations.get(storeName as keyof typeof this.stores)?.has(stateName)) {\n        this.propStateRegistrations.get(storeName as keyof typeof this.stores)?.set(stateName, [\n          {\n            elementId: element.dataset.nylasId,\n            propKey,\n          },\n        ]);\n      } else {\n        this.propStateRegistrations\n          .get(storeName as keyof typeof this.stores)\n          ?.get(stateName)\n          ?.push({\n            elementId: element.dataset.nylasId,\n            propKey,\n          });\n      }\n\n      // Set the prop value on the component\n      (element as { [key: string]: any })[propKey.toString()] = stateValue;\n      debug(`[${this.hostTagName}] Setting \"${component.name}\" prop \"${propKey.toString()}\" to \"${stateKey}\" value.`, { stateValue });\n    });\n\n    /**\n     * We allow components to also map props from the provider to the component.\n     */\n    localPropsToProp?.forEach((propKey, value) => {\n      const mappedPropValue = this.host[value]; // TODO: Is this safe? We should find a way to only limit it to public properties and no methods.\n      (element as { [key: string]: any })[propKey.toString()] = mappedPropValue;\n      debug(`[${this.hostTagName}] Setting \"${component.name}\" prop \"${propKey.toString()}\" to the value of \"${value}\" value.`, { value, mappedPropValue });\n    });\n\n    /**\n     * We allow components to access the getStore method directly.\n     */\n    if (getStoresToProp) {\n      (element as { [key: string]: any })[getStoresToProp?.toString()] = this.getStore;\n      debug(`[${this.hostTagName}] Setting \"${component.name}\" prop \"${getStoresToProp.toString()}\" to \"getStore\" method.`);\n    }\n\n    /**\n     * We allow components to map a store to a prop for direct access.\n     */\n    storeToProps?.forEach((propKey, storeKey) => {\n      const store = this.getStore(storeKey);\n      (element as { [key: string]: any })[propKey.toString()] = store;\n      debug(`[${this.hostTagName}] Setting \"${component.name}\" prop \"${propKey.toString()}\" to \"${storeKey}\" store.`, { store });\n    });\n\n    /**\n     * We allow components to map the NylasConnector instance to a prop for direct access.\n     */\n    if (connectorToProp) {\n      (element as { [key: string]: any })[connectorToProp?.toString()] = this.nylasConnector;\n      debug(`[${this.hostTagName}] Setting \"${component.name}\" prop \"${connectorToProp.toString()}\" to \"nylasConnector\" value.`, { connectorToProp });\n    }\n\n    debug(`[${this.hostTagName}] Component ${component.name} registered.`);\n  }\n\n  /**\n   * This is a method that is used to unregister a component with the provider.\n   * @param component HTMLElement to unregister\n   * @returns void\n   */\n  public unregisterComponent(component: RegisteredComponent<any, any>): void {\n    debug(`[${this.hostTagName}] Unregistering component ${component.name}.`);\n\n    // Get component element id\n    const elementId = component.element.dataset.nylasId;\n    if (!elementId) {\n      debug(`[${this.hostTagName}] Component ${component.name} not registered. Skipping.`);\n      return;\n    }\n\n    // Make sure the component is not already registered\n    if (this.registeredComponents[elementId]) {\n      debug(`[${this.hostTagName}] Component ${component.name} not registered. Skipping.`);\n      return;\n    }\n\n    // Remove the component prop registration from propStateRegistrations\n    this.propStateRegistrations.forEach((stateToProps, storeName) => {\n      stateToProps.forEach((_, stateKey) => {\n        const props = this.propStateRegistrations.get(storeName)?.get(stateKey);\n        const filteredProps = props?.filter(prop => prop.elementId !== elementId);\n        if (filteredProps) {\n          this.propStateRegistrations.get(storeName)?.set(stateKey, filteredProps);\n        }\n      });\n    });\n\n    // Before we unregister the component, we need to remove any event listeners\n    const eventListenerRegistrations = this.eventListenerRegistrations.get(elementId);\n    eventListenerRegistrations?.forEach(([element, propKey, handler]) => {\n      const eventName = formatEventName(propKey.toString());\n      debug(`[${this.hostTagName}] Removing event listener for \"${eventName}\" on \"${element.tagName}\"`);\n      element.removeEventListener(eventName, handler as unknown as EventListener);\n    });\n\n    // Unregister the component\n    delete this.registeredComponents[elementId];\n  }\n\n  /**\n   * This method is used to dynamically retrieve the appropriate store\n   * @param name store name\n   */\n  public getStore<K extends keyof Stores>(name: K): Stores[K] {\n    const store = this.stores[name];\n    if (!store) {\n      throw new Error(`[${this.hostTagName}] Store \"${name.toString()}\" not found.`);\n    }\n    return store;\n  }\n\n  /**\n   * This method is called when the component is connected to the DOM.\n   * We're using this method to listen for changes in the store and update\n   * the registered components with the new values.\n   */\n  private async setupStoreListeners() {\n    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    /**\n     * This is a rather simple way for us to listen for changes in the store\n     * and make sure our registered components are updated with the new values.\n     *\n     * For each store change, we loop through each registered component and\n     * check if the store change is mapped to a prop on the component. If it is,\n     * we set the prop to the new value.\n     *\n     * We call this super early in the provider lifecycle so that we can make sure\n     * that all components have the correct props before they are rendered.\n     */\n    Object.entries(this.stores).forEach(([storeName, store]) => {\n      debug(`[${self.hostTagName}] Listening for changes in \"${storeName}\" store.`);\n      store.use({\n        set(stateKey, newValue, oldValue) {\n          debug(`[${self.hostTagName}] Store \"${storeName}\" state \"${stateKey.toString()}\" changed`, { newValue, oldValue });\n          if (newValue === oldValue) {\n            debug(`[${self.hostTagName}] Store \"${storeName}\" state \"${stateKey.toString()}\" unchanged. Skipping.`);\n            return;\n          }\n\n          const registeredComponents = self.registeredComponents;\n          if (!registeredComponents) {\n            debug(`[${self.hostTagName}] No registered components found. Skipping.`);\n            return;\n          }\n\n          // Get our prop registrations for this store\n          const props = self.propStateRegistrations.get(storeName as keyof typeof self.stores as string)?.get(stateKey.toString()) || [];\n          debug(`[${self.hostTagName}] Found ${props.length} prop(s) registered for \"${stateKey.toString()}\" store.`, {\n            props,\n            propStateRegistrations: self.propStateRegistrations,\n          });\n\n          // Loop through each registered component and update the prop\n          props.forEach(({ elementId, propKey }) => {\n            const component = registeredComponents[elementId];\n            if (!component) {\n              debug(`[${self.hostTagName}] Component \"${elementId}\" not found. Skipping.`, { component });\n              return;\n            }\n\n            // Get the appropriate store\n            const loadedStore = self.getStore(storeName as keyof typeof self.stores as string);\n            const stateValue = loadedStore.state[stateKey as unknown as keyof typeof loadedStore.state];\n            (component.element as { [key: string]: any })[propKey.toString()] = stateValue;\n            debug(`[${self.hostTagName}] Setting \"${component.name}\" prop \"${propKey.toString()}\" to \"${stateKey.toString()}\" value.`, { stateValue });\n          });\n        },\n      });\n    });\n  }\n\n  /**\n   * Simple getter for the host element tag name.\n   */\n  private get hostTagName(): string {\n    return this.host?.tagName?.toLowerCase() ?? 'nylas-provider';\n  }\n}\n\nexport class NylasBaseProvider<T extends Record<string, ObservableMap<any>>> extends NylasAbstractProvider<T> {}\n"]}