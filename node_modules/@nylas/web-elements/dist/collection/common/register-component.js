import { debug, error } from "../utils/utils";
import { getElement } from "@stencil/core";
export function createComponentEvent(instance, registeredComponent, eventName = 'registerComponent') {
    return new CustomEvent(eventName, {
        bubbles: true,
        composed: true,
        detail: registeredComponent,
    });
}
export function unregisterComponentEvent(instance, registeredComponent, eventName = 'unregisterComponent') {
    return new CustomEvent(eventName, {
        bubbles: true,
        composed: true,
        detail: registeredComponent,
    });
}
export function RegisterComponent(config) {
    return (target, propKey) => {
        const componentName = config.name;
        debug(`[${componentName}] Registering component ${componentName} being called on ${propKey}`);
        const origionalCallback = target.componentWillLoad;
        if (!origionalCallback) {
            error(`[${componentName}] componentWillLoad lifecycle method in ${componentName} missing. Required for RegisterComponent decorator.`);
            return;
        }
        const origionalConnectCallback = target.connectedCallback;
        if (!origionalConnectCallback) {
            error(`[${componentName}] connectedCallback lifecycle method in ${componentName} missing. Required for RegisterComponent decorator.`);
            return;
        }
        const origionalDisconnectCallback = target.disconnectedCallback;
        if (!origionalDisconnectCallback) {
            error(`[${componentName}] disconnectedCallback lifecycle method in ${componentName} missing. Required for RegisterComponent decorator.`);
            return;
        }
        if (config.storeToProps && config.stateToProps) {
            const storeToPropsKeys = Array.from(config.storeToProps.values());
            const stateToPropsKeys = Array.from(config.stateToProps.values());
            const intersection = storeToPropsKeys.filter(key => stateToPropsKeys.includes(key));
            if (intersection.length > 0) {
                error(`[${componentName}] Overlapping prop keys detected in ${componentName} for storeToProps and stateToProps. Make sure to only define them once. Overlapping keys: ${intersection.join(', ')}`);
                return;
            }
        }
        const eventToPropsMap = new Map();
        if (config.eventToProps) {
            Object.keys(config.eventToProps).forEach(key => {
                eventToPropsMap.set(key, config.eventToProps?.[key]);
            });
        }
        target.connectedCallback = function () {
            debug(`[~${componentName}] connectedCallback called`);
            const origionalResult = origionalConnectCallback?.call(this);
            const host = getElement(this);
            if (host.dataset.nylasId) {
                return origionalResult;
            }
            Object.defineProperty(host, 'registerNylasComponent', {
                get() {
                    return true;
                },
                enumerable: true,
            });
            Object.defineProperty(host, 'stateToProps', {
                get() {
                    return config.stateToProps;
                },
                enumerable: true,
            });
            Object.defineProperty(host, 'getStoresToProp', {
                get() {
                    return config.getStoresToProp;
                },
                enumerable: true,
            });
            Object.defineProperty(host, 'storeToProps', {
                get() {
                    return config.storeToProps;
                },
                enumerable: true,
            });
            Object.defineProperty(host, 'eventToProps', {
                get() {
                    return eventToPropsMap;
                },
                enumerable: true,
            });
            Object.defineProperty(host, 'authToProp', {
                get() {
                    return config.authToProp;
                },
                enumerable: true,
            });
            Object.defineProperty(host, 'connectorToProp', {
                get() {
                    return config.connectorToProp;
                },
                enumerable: true,
            });
            Object.defineProperty(host, 'localPropsToProp', {
                get() {
                    return config.localPropsToProp;
                },
                enumerable: true,
            });
            return origionalResult;
        };
        if (config.fireRegisterEvent) {
            target.componentWillLoad = function () {
                const origionalResult = origionalCallback?.call(this);
                const host = getElement(this);
                const registeredComponent = {
                    element: host,
                    ...config,
                    eventToProps: eventToPropsMap,
                };
                const event = createComponentEvent(target, registeredComponent, config.registrationEventName);
                if (host.dispatchEvent(event)) {
                    debug(`[${componentName}] Component ${componentName} successfully fired registration event`);
                }
                return origionalResult;
            };
            target.disconnectedCallback = function () {
                const origionalResult = origionalDisconnectCallback?.call(this);
                const host = getElement(this);
                const registeredComponent = {
                    element: host,
                    ...config,
                    eventToProps: eventToPropsMap,
                };
                const event = unregisterComponentEvent(target, registeredComponent, config.unregistrationEventName);
                if (host.dispatchEvent(event)) {
                    debug(`[${componentName}] Component ${componentName} successfully fired unregistration event`);
                }
                return origionalResult;
            };
        }
    };
}
//# sourceMappingURL=register-component.js.map
