import { debug, formatEventName, uniqueID } from "../utils/utils";
export class NylasAbstractProvider {
    constructor(host, stores, automaticComponentRegistration = true, eventOverrides) {
        this.automaticComponentRegistration = true;
        this.registeredComponents = {};
        this.propStateRegistrations = new Map();
        this.eventListenerRegistrations = new Map();
        this.host = host;
        this.stores = stores;
        this.automaticComponentRegistration = automaticComponentRegistration;
        this.eventOverrides = eventOverrides;
        debug(`[${this.hostTagName}] Initializing (abstract) provider.`, { eventOverrides });
        this.registerComponent = this.registerComponent.bind(this);
        this.getStore = this.getStore.bind(this);
        Object.keys(this.stores).forEach(storeName => {
            this.propStateRegistrations.set(storeName, new Map());
        });
    }
    async componentWillLoad(nylasConnector) {
        debug(`[${this.hostTagName}] Will load`);
        this.setupStoreListeners();
        this.nylasConnector = nylasConnector;
        const childComponents = Array.from(this.host.querySelectorAll('*')).filter(child => child.tagName.toLowerCase().startsWith('nylas-'));
        debug(`[${this.hostTagName}] Found ${childComponents.length} child component(s).`, { childComponents });
        childComponents.forEach(child => {
            const component = child;
            if (!component) {
                debug(`[~${this.hostTagName}] Component ${component.tagName} does not have a name. Skipping.`);
                return;
            }
            if (!component.registerNylasComponent) {
                debug(`[~${this.hostTagName}] Component ${component.tagName} is not a component that can be registered. Skipping.`, { component });
                return;
            }
            const registeredComponent = {
                element: component,
                name: component.tagName.toLowerCase(),
                getStoresToProp: component.getStoresToProp,
                storeToProps: component.storeToProps,
                stateToProps: component.stateToProps,
                authToProp: component.authToProp,
                eventToProps: component.eventToProps,
                connectorToProp: component.connectorToProp,
                localPropsToProp: component.localPropsToProp,
            };
            this.registerComponent(registeredComponent);
        });
    }
    async componentDidLoad() {
        debug(`[${this.hostTagName}] Did load`);
    }
    async componentDisconnected() {
        Object.values(this.stores).forEach(store => {
            store.dispose();
        });
    }
    async registerComponentHandler(event) {
        event.stopPropagation();
        if (!this.automaticComponentRegistration) {
            debug(`[${this.hostTagName}] Automatic component registration disabled. Skipping registration of ${event.detail.name}.`);
            return;
        }
        this.registerComponent(event.detail);
    }
    async unregisterComponentHandler(event) {
        event.stopPropagation();
        if (!this.automaticComponentRegistration) {
            debug(`[${this.hostTagName}] Automatic component registration disabled. Skipping unregistration of ${event.detail.name}.`);
            return;
        }
        this.unregisterComponent(event.detail);
    }
    registerComponent(component) {
        debug(`[${this.hostTagName}] Registering component ${component.name}.`);
        const elementId = component.element.dataset.nylasId;
        if (elementId && this.registeredComponents[elementId]) {
            debug(`[${this.hostTagName}] Component ${component.name} already registered. Skipping.`);
            return;
        }
        const { stateToProps, getStoresToProp, eventToProps, storeToProps, connectorToProp, localPropsToProp, element } = component;
        element.dataset.nylasId = uniqueID();
        this.registeredComponents[element.dataset.nylasId] = component;
        const eventOverrides = this.eventOverrides;
        eventToProps?.forEach((customEventHandler, propKey) => {
            const nylasConnector = this.nylasConnector;
            const handler = async (event) => {
                debug(`[${this.hostTagName}] Handling "${component.name}" prop "${String(propKey)}" event.`, { event });
                if (propKey in eventOverrides) {
                    debug(`[${this.hostTagName}] Found event override for "${String(propKey)}" event. Calling override.`);
                    await eventOverrides[propKey](event, nylasConnector);
                }
                if (!event.defaultPrevented) {
                    await customEventHandler(event, nylasConnector);
                }
                return;
            };
            const elementId = component.element.dataset.nylasId;
            if (elementId && !this.eventListenerRegistrations.has(elementId)) {
                this.eventListenerRegistrations.set(elementId, []);
            }
            if (elementId) {
                this.eventListenerRegistrations.get(elementId)?.push([element, propKey, handler]);
            }
            debug(`[${this.hostTagName}] Setting "${component.name}" event "${String(propKey)}" to automcially call NylasConnector method.`);
            const eventName = formatEventName(propKey.toString());
            debug(`[${this.hostTagName}] Adding event listener for "${eventName}" on "${element.tagName}"`);
            element.addEventListener(eventName, handler);
        });
        stateToProps?.forEach((propKey, stateKey) => {
            const [storeName, stateName] = stateKey.split('.');
            const store = this.getStore(storeName);
            const stateValue = store.state[stateName];
            if (!element.dataset.nylasId) {
                debug(`[${this.hostTagName}] Component "${component.name}" not registered. Skipping.`, { component });
                return;
            }
            if (!this.propStateRegistrations.has(storeName)) {
                this.propStateRegistrations.set(storeName, new Map());
            }
            if (!this.propStateRegistrations.get(storeName)?.has(stateName)) {
                this.propStateRegistrations.get(storeName)?.set(stateName, [
                    {
                        elementId: element.dataset.nylasId,
                        propKey,
                    },
                ]);
            }
            else {
                this.propStateRegistrations
                    .get(storeName)
                    ?.get(stateName)
                    ?.push({
                    elementId: element.dataset.nylasId,
                    propKey,
                });
            }
            element[propKey.toString()] = stateValue;
            debug(`[${this.hostTagName}] Setting "${component.name}" prop "${propKey.toString()}" to "${stateKey}" value.`, { stateValue });
        });
        localPropsToProp?.forEach((propKey, value) => {
            const mappedPropValue = this.host[value];
            element[propKey.toString()] = mappedPropValue;
            debug(`[${this.hostTagName}] Setting "${component.name}" prop "${propKey.toString()}" to the value of "${value}" value.`, { value, mappedPropValue });
        });
        if (getStoresToProp) {
            element[getStoresToProp?.toString()] = this.getStore;
            debug(`[${this.hostTagName}] Setting "${component.name}" prop "${getStoresToProp.toString()}" to "getStore" method.`);
        }
        storeToProps?.forEach((propKey, storeKey) => {
            const store = this.getStore(storeKey);
            element[propKey.toString()] = store;
            debug(`[${this.hostTagName}] Setting "${component.name}" prop "${propKey.toString()}" to "${storeKey}" store.`, { store });
        });
        if (connectorToProp) {
            element[connectorToProp?.toString()] = this.nylasConnector;
            debug(`[${this.hostTagName}] Setting "${component.name}" prop "${connectorToProp.toString()}" to "nylasConnector" value.`, { connectorToProp });
        }
        debug(`[${this.hostTagName}] Component ${component.name} registered.`);
    }
    unregisterComponent(component) {
        debug(`[${this.hostTagName}] Unregistering component ${component.name}.`);
        const elementId = component.element.dataset.nylasId;
        if (!elementId) {
            debug(`[${this.hostTagName}] Component ${component.name} not registered. Skipping.`);
            return;
        }
        if (this.registeredComponents[elementId]) {
            debug(`[${this.hostTagName}] Component ${component.name} not registered. Skipping.`);
            return;
        }
        this.propStateRegistrations.forEach((stateToProps, storeName) => {
            stateToProps.forEach((_, stateKey) => {
                const props = this.propStateRegistrations.get(storeName)?.get(stateKey);
                const filteredProps = props?.filter(prop => prop.elementId !== elementId);
                if (filteredProps) {
                    this.propStateRegistrations.get(storeName)?.set(stateKey, filteredProps);
                }
            });
        });
        const eventListenerRegistrations = this.eventListenerRegistrations.get(elementId);
        eventListenerRegistrations?.forEach(([element, propKey, handler]) => {
            const eventName = formatEventName(propKey.toString());
            debug(`[${this.hostTagName}] Removing event listener for "${eventName}" on "${element.tagName}"`);
            element.removeEventListener(eventName, handler);
        });
        delete this.registeredComponents[elementId];
    }
    getStore(name) {
        const store = this.stores[name];
        if (!store) {
            throw new Error(`[${this.hostTagName}] Store "${name.toString()}" not found.`);
        }
        return store;
    }
    async setupStoreListeners() {
        const self = this;
        Object.entries(this.stores).forEach(([storeName, store]) => {
            debug(`[${self.hostTagName}] Listening for changes in "${storeName}" store.`);
            store.use({
                set(stateKey, newValue, oldValue) {
                    debug(`[${self.hostTagName}] Store "${storeName}" state "${stateKey.toString()}" changed`, { newValue, oldValue });
                    if (newValue === oldValue) {
                        debug(`[${self.hostTagName}] Store "${storeName}" state "${stateKey.toString()}" unchanged. Skipping.`);
                        return;
                    }
                    const registeredComponents = self.registeredComponents;
                    if (!registeredComponents) {
                        debug(`[${self.hostTagName}] No registered components found. Skipping.`);
                        return;
                    }
                    const props = self.propStateRegistrations.get(storeName)?.get(stateKey.toString()) || [];
                    debug(`[${self.hostTagName}] Found ${props.length} prop(s) registered for "${stateKey.toString()}" store.`, {
                        props,
                        propStateRegistrations: self.propStateRegistrations,
                    });
                    props.forEach(({ elementId, propKey }) => {
                        const component = registeredComponents[elementId];
                        if (!component) {
                            debug(`[${self.hostTagName}] Component "${elementId}" not found. Skipping.`, { component });
                            return;
                        }
                        const loadedStore = self.getStore(storeName);
                        const stateValue = loadedStore.state[stateKey];
                        component.element[propKey.toString()] = stateValue;
                        debug(`[${self.hostTagName}] Setting "${component.name}" prop "${propKey.toString()}" to "${stateKey.toString()}" value.`, { stateValue });
                    });
                },
            });
        });
    }
    get hostTagName() {
        return this.host?.tagName?.toLowerCase() ?? 'nylas-provider';
    }
}
export class NylasBaseProvider extends NylasAbstractProvider {
}
//# sourceMappingURL=abstract-provider.js.map
