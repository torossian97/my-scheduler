import { Config, AuthConfig, IDToken, ProviderList } from "./@types";
import { Storage } from "./client/store";
import IndexedDBStorage from "./client/indexedDB";
import { sha256 } from "js-sha256";
import { Buffer } from "buffer";
import { v4 as uuid } from "uuid";
import {
  FetchEventSourceInit,
  fetchEventSource,
} from "@microsoft/fetch-event-source";
import { Base64EncodeUrl, getTimestamp } from "./helpers";
import jwtDecode from "jwt-decode";

export class NylasSessions {
  private clientId: string;
  private redirectUri: string;
  private accessType = "online";
  private domain = "http://api.nylas.com";
  private versioned = false;
  private Storage: Storage;
  private hosted = false;
  private multiAccount = false;
  private loginId: string = "";
  public constructor(config: Config) {
    this.clientId = config.clientId;
    this.redirectUri = config.redirectUri;
    if (config.domain) {
      this.domain = config.domain;
      const versionedPart = this.domain.substring(this.domain.length - 3);
      if (versionedPart.includes("/v")) {
        this.versioned = true;
      }
    }
    if (config.multiAccount) {
      this.multiAccount = config.multiAccount;
    }
    if (config.sw) {
      const storage = new IndexedDBStorage();
      this.Storage = new Storage(storage);
    } else {
      this.Storage = new Storage();
    }
    if (config.accessType) {
      this.accessType = config.accessType;
    }
    if (config.loginId) {
      this.loginId = config.loginId;
    }

    if (config.hosted) {
      this.hosted = config.hosted;
    }

    this.codeExchange(null);

    // check();
    // registerServiceWorker();
  }
  // Validates access token
  public async validateAccessToken(grant_id: string = ""): Promise<boolean> {
    const { access_token } = await this.Storage.getGrant(
      grant_id,
      this.multiAccount,
    );

    try {
      const response: any = await fetch(
        `${this.domain}/connect/tokeninfo?access_token=${access_token}`,
        {
          method: "GET",
        },
      );
      const responseData = await response.json();
      if (!responseData.data) {
        return false;
      }
      return true;
    } catch (error) {
      return false;
    }
  }
  // Validates id token
  public async validateIDToken(grant_id: string = ""): Promise<boolean> {
    const { id_token } = await this.Storage.getGrant(
      grant_id,
      this.multiAccount,
    );

    try {
      const response: any = await fetch(
        `${this.domain}/connect/tokeninfo?id_token=${id_token}`,
        {
          method: "GET",
        },
      );
      if (response.status !== 200) {
        return false;
      }
      const responseData = await response.json();
      if (!responseData.data) {
        return false;
      }
      return true;
    } catch (error) {
      return false;
    }
  }

  // Gets domain of UAS
  public getDomain() {
    return this.domain;
  }

  // Gets auth link
  public async auth(config: AuthConfig) {
    if (
      this.hosted &&
      (this.domain === window.location.origin ||
        (this.versioned && this.domain.includes(window.location.origin)))
    ) {
      await this.hostedSetCodeChallenge();
    }
    const url = await this.generateAuthURL(config);
    if (config.popup) {
      this.popUp(url);
      return;
    }
    return url;
  }

  // Generates auth URL
  private async generateAuthURL(config: AuthConfig): Promise<string> {
    const codeChallenge = await this.getCodeChallege();
    let url = `${this.domain}/connect/auth?client_id=${this.clientId}&redirect_uri=${this.redirectUri}&access_type=${this.accessType}&response_type=code`;
    if (codeChallenge) {
      url += `&code_challenge=${codeChallenge}&code_challenge_method=S256&options=rotate_refresh_token`;
    }
    if (config.provider) {
      url += `&provider=${config.provider}`;
    }
    if (config.loginHint) {
      url += `&login_hint=${config.loginHint}`;
      if (config.includeGrantScopes) {
        url += `&include_grant_scopes=${config.includeGrantScopes}`;
      }
    }
    if (config.scope) {
      url += `&scope=${config.scope.join(" ")}`;
    }
    if (config.prompt) {
      url += `&prompt=${config.prompt}`;
    }
    if (config.metadata) {
      url += `&metadata=${config.metadata}`;
    }
    if (config.state || this.loginId) {
      url += `&state=${this.loginId ? this.loginId : config.state}`;
    }
    return url;
  }
  // Generates auth URL
  public async generateReauthURL(
    grant_id: string,
    scopes: string[],
  ): Promise<string> {
    if (!grant_id) {
      throw new Error("Grant ID is required");
    }
    const userToken = await this.Storage.getUserToken(grant_id);
    const codeChallenge = await this.getCodeChallege();
    let url = `${this.domain}/connect/auth?client_id=${this.clientId}&redirect_uri=${this.redirectUri}&access_type=${this.accessType}&response_type=code`;
    if (codeChallenge) {
      url += `&code_challenge=${codeChallenge}&code_challenge_method=S256&options=rotate_refresh_token`;
    }
    if (userToken?.provider) {
      url += `&provider=${userToken.provider}`;
    }
    if (userToken?.email) {
      url += `&login_hint=${userToken.email}`;
    }
    if (scopes) {
      url += `&scope=${scopes.join(" ")}`;
    }
    return url;
  }

  // Generates UUID code challenge
  public async generateCodeChallenge() {
    const code_verifier = await this.Storage.getPKCE();
    if (code_verifier) {
      return;
    }
    const codeChallenge = uuid();
    this.Storage.setPKCE(codeChallenge);
    return;
  }

  // Gets code challenge from URL query params
  private async hostedSetCodeChallenge() {
    if (!this.hosted) {
      throw console.error("Method only used with hosted flag enabled");
    }
    const params = new URLSearchParams(window.location.search);
    const codeChallenge = params.get("code_challenge");
    if (!codeChallenge) {
      const code_verifier = await this.Storage.getPKCE();
      if (code_verifier) {
        return;
      }
      console.warn("Code challenge is recomended");
      return;
    }
    this.Storage.setPKCE(codeChallenge);
  }
  // Gets code challenge from store
  private async getCodeChallege(): Promise<string> {
    if (
      this.hosted &&
      (this.domain === window.location.origin ||
        (this.versioned && this.domain.includes(window.location.origin)))
    ) {
      const params = new URLSearchParams(window.location.search);
      const codeChallenge = params.get("code_challenge");
      if (!codeChallenge) {
        console.warn("Code challenge is recomended");
        return "";
      }
      return codeChallenge;
    }
    const code_verifier = await this.Storage.getPKCE();
    if (code_verifier) {
      const codeChallengeHashed = sha256(code_verifier);
      let codeChallengeEncrypted =
        Buffer.from(codeChallengeHashed).toString("base64");
      codeChallengeEncrypted = Base64EncodeUrl(codeChallengeEncrypted);
      return codeChallengeEncrypted;
    }
    return "";
  }
  // checks if user is logged in
  public async isLoggedIn(): Promise<boolean> {
    // if hosted identity isLoggedIn always returns false
    if (
      this.hosted &&
      (this.domain === window.location.origin ||
        (this.versioned && this.domain.includes(window.location.origin)))
    ) {
      return false;
    }
    const tokens = await this.Storage.getUserTokens();
    if (tokens && tokens.length > 0) {
      if (this.multiAccount) {
        await this.generateCodeChallenge();
      }
      return true;
    }
    await this.generateCodeChallenge();
    return false;
  }

  // Checks if user is multi account
  public isMultiAccount(): boolean {
    return this.multiAccount;
  }

  // Logs user out
  public async logout() {
    const profile = await this.getProfile();
    await this.Storage.clearSession();
    const payload: CustomEventInit = { detail: profile };
    window.dispatchEvent(new CustomEvent("onLogoutSuccess", payload));
  }

  // Gets profile info from ID token
  public async getProfile(grant_id = ""): Promise<IDToken | null> {
    let tok;
    if (grant_id) {
      tok = await this.Storage.getUserToken(grant_id);
    } else {
      tok = await this.Storage.getUserToken();
    }
    if (tok) {
      return tok;
    }
    return null;
  }
  // Gets profile info from ID tokens
  public async getProfiles(): Promise<IDToken[] | null> {
    const tok = await this.Storage.getUserTokens();
    if (tok) {
      return tok;
    }
    return null;
  }

  // Remove a specific profile
  public async removeProfile(id: string): Promise<null> {
    await this.Storage.removeUserToken(id);
    await this.Storage.removeGrant(id);
    return null;
  }

  // IMAP authentication
  public async authIMAP(data: any): Promise<any> {
    const code_challenge = await this.getCodeChallege();
    const payload: any = {
      imap_username: data.username,
      imap_password: data.password,
      imap_host: data.hostIMAP,
      imap_port: data.portIMAP,
      type: data.type,
      smtp_host: data.hostSMTP,
      smtp_port: data.portSMTP,
      provider: data.provider,
      redirect_uri: this.redirectUri,
      state: data.state,
      public_application_id: this.clientId,
      access_type: this.accessType,
    };
    if (this.loginId) {
      payload.id = this.loginId;
    }
    if (code_challenge != "") {
      payload.code_challenge = code_challenge;
      payload.code_challenge_method = "S256";
    }
    const response: any = await fetch(`${this.domain}/connect/login/imap`, {
      method: "POST", // or 'PUT'
      headers: new Headers({ "content-type": "application/json" }),
      body: JSON.stringify(payload),
    });
    const responseData = await response.json();
    return responseData;
  }
  // EWS authentication
  public async authEWS(data: any): Promise<any> {
    const code_challenge = await this.getCodeChallege();
    const payload: any = {
      ...data,
      redirect_uri: this.redirectUri,
      public_application_id: this.clientId,
      access_type: this.accessType,
    };
    if (this.loginId) {
      payload.id = this.loginId;
    }
    if (code_challenge != "") {
      payload.code_challenge = code_challenge;
      payload.code_challenge_method = "S256";
    }
    const response: any = await fetch(`${this.domain}/connect/login/ews`, {
      method: "POST", // or 'PUT'
      headers: new Headers({ "content-type": "application/json" }),
      body: JSON.stringify(payload),
    });
    const responseData = await response.json();
    return responseData;
  }

  // Detects email
  public async detectEmail(email: string): Promise<any> {
    const response: any = await fetch(
      `${
        this.versioned ? this.domain : this.domain + "/connect"
      }/providers/detect?client_id=${this.clientId}&email=${email}`,
      {
        method: "POST", // or 'PUT'
        headers: new Headers({ "content-type": "application/json" }),
      },
    );
    const responseData = await response.json();
    return responseData.data;
  }
  // Gets app info from UAS
  public async applicationInfo(): Promise<any> {
    const response: any = await fetch(
      `${
        this.versioned ? this.domain : this.domain + "/connect"
      }/applications?client_id=${this.clientId}`,
      {
        method: "GET", // or 'PUT'
        headers: new Headers({ "content-type": "application/json" }),
      },
    );
    const responseData = await response.json();
    return responseData.data;
  }

  // Gets providers form UAS
  public async getAvailableProviders(): Promise<ProviderList[] | null> {
    const response: any | undefined = await fetch(
      `${this.domain}/connect/providers/find?client_id=${this.clientId}`,
      {
        method: "GET", // or 'PUT'
        headers: new Headers({ "content-type": "application/json" }),
      },
    );
    if (response) {
      const responseData = await response.json();
      const providers = responseData.data;
      return providers;
    }
    return null;
  }
  // EVENT HOOKS
  public onLoginSuccess(callback: Function): void {
    window.addEventListener("onLoginSuccess", (e) => callback(e));
  }
  public onLogoutSuccess(callback: Function): void {
    window.addEventListener("onLogoutSuccess", (e) => callback(e));
  }
  public onLoginFail(callback: any): void {
    window.addEventListener("onLoginFail", (e) => callback(e));
  }
  public onTokenRefreshSuccess(callback: Function): void {
    window.addEventListener("onTokenRefreshSuccess", (e) => callback(e));
  }
  public onTokenRefreshFail(callback: any): void {
    window.addEventListener("onTokenRefreshFail", (e) => callback(e));
  }
  public onSessionExpired(callback: any): void {
    window.addEventListener("onSessionExpired", (e) => callback(e));
  }
  // Exchanges code for ID token and refresh and access tokens
  public async codeExchange(search: string | null) {
    let params = new URLSearchParams(window.location.search);
    if (search) {
      params = new URLSearchParams(search);
    }
    const code = params.get("code");
    const state = params.get("state");
    const error = params.get("error");
    const error_description = params.get("error_description");
    const error_code = params.get("error_code");

    if (error && error_description && error_code) {
      const payload: CustomEventInit = {
        detail: { error, error_description, error_code },
      };
      window.dispatchEvent(new CustomEvent("onLoginFail", payload));
      window.history.pushState({}, document.title, window.location.pathname);
      return false;
    }
    if (!code) {
      console.warn("No code found");
      return false;
    }
    // If popup window stop internal code exchange
    if (window.opener && window.name === "uas-popup") {
      console.warn("Popup window detected");
      return false;
    }
    // Get PKCE code_challenge from local storage
    const code_verifier = await this.Storage.getPKCE();
    if (!code_verifier) {
      console.warn("No code verifier found");
      return false;
    }
    // Prepare request
    try {
      const payload = {
        client_id: this.clientId,
        redirect_uri: this.redirectUri,
        code: code,
        grant_type: "authorization_code",
        code_verifier: code_verifier,
      };
      const response: any = await fetch(`${this.domain}/connect/token`, {
        method: "POST", // or 'PUT'
        headers: new Headers({ "content-type": "application/json" }),
        body: JSON.stringify(payload),
      });
      const responseData = await response.json();
      // Parse response
      // Store ID token
      if (responseData) {
        if (responseData.error) {
          const payload: CustomEventInit = { detail: responseData };
          window.dispatchEvent(new CustomEvent("onLoginFail", payload));
          return true;
        }
        const exchangeResponse =
          await this.handleCodeExchangeResponse(responseData);
        if (!exchangeResponse.valid) {
          const payload: CustomEventInit = { detail: exchangeResponse.data };
          window.dispatchEvent(new CustomEvent("onLoginFail", payload));
          return true;
        } else {
          if (state) {
            exchangeResponse.data.state = state;
          }
          const payload: CustomEventInit = { detail: exchangeResponse.data };
          window.dispatchEvent(new CustomEvent("onLoginSuccess", payload));
          window.history.pushState(
            {},
            document.title,
            window.location.pathname,
          );
        }
      }
      this.Storage.removePKCE();
      return true;
      // Remove PKCE code_challenge from local storage
    } catch (error: any) {
      const payload: CustomEventInit = { detail: error };
      window.dispatchEvent(new CustomEvent("onLoginFail", payload));
      window.history.pushState({}, document.title, window.location.pathname);
      return false;
    }
  }

  // Token Exchange for session  maintenece
  public async tokenExchange(grant_id: string = "") {
    const { refresh_token } = await this.Storage.getGrant(
      grant_id,
      this.multiAccount,
    );
    try {
      const payload = {
        client_id: this.clientId,
        redirect_uri: this.redirectUri,
        refresh_token,
        grant_type: "refresh_token",
      };
      const response: any = await fetch(`${this.domain}/connect/token`, {
        method: "POST",
        headers: new Headers({ "content-type": "application/json" }),
        body: JSON.stringify(payload),
      });
      const responseData = await response.json();

      // Parse response
      // Store ID token
      if (responseData) {
        if (responseData.error) {
          const payload: CustomEventInit = { detail: responseData };
          window.dispatchEvent(new CustomEvent("onTokenRefreshFail", payload));
          return true;
        }
        const now = getTimestamp();
        responseData.expires_in = now + responseData.expires_in;
        this.Storage.setGrant(responseData, this.multiAccount);
        const isValidToken = await this.validateIDToken(grant_id);
        if (!isValidToken) {
          const payload: CustomEventInit = { detail: responseData };
          window.dispatchEvent(new CustomEvent("onTokenRefreshFail", payload));
          return true;
        }
        const payload: CustomEventInit = { detail: responseData };
        window.dispatchEvent(new CustomEvent("onTokenRefreshSuccess", payload));
        return true;
      }
      // Remove PKCE code_challenge from local storage
      this.Storage.removePKCE();
    } catch (error: any) {
      const payload: CustomEventInit = { detail: error };
      window.dispatchEvent(new CustomEvent("onTokenRefreshFail", payload));
      return false;
    }
  }
  // Handles the response of code exchange
  private async handleCodeExchangeResponse(responseData: any) {
    const isValid = true;
    if (responseData.error) {
      return {
        data: responseData,
        valid: false,
      };
    }
    const now = getTimestamp();
    responseData.expires_in = now + responseData.expires_in;
    this.Storage.setGrant(responseData, this.multiAccount);
    const user: IDToken = jwtDecode(responseData.id_token);
    user.status = "authenticated";
    this.Storage.setUserToken(user);
    const isValidToken = await this.validateIDToken(user.sub);
    if (!isValidToken) {
      return {
        data: responseData,
        valid: false,
      };
    }
    return {
      data: responseData,
      valid: isValid,
    };
  }

  // Regulates POPUP behaivior
  public async popUp(url: string) {
    const width = 500;
    const height = 600;
    const left = window.screenX + (window.outerWidth - width) / 2;
    const top = window.screenY + (window.outerHeight - height) / 2.5;
    const title = `uas-popup`;
    const popupURL = url;
    const externalPopup = window.open(
      popupURL,
      title,
      `width=${width},height=${height},left=${left},top=${top}`,
    );
    if (!externalPopup) {
      return;
    }
    const timer = setInterval(async () => {
      if (externalPopup.closed) {
        const payload: CustomEventInit = {
          detail: { error_description: "OAuth provider window closed" },
        };
        window.dispatchEvent(new CustomEvent("onLoginFail", payload));
        timer && clearInterval(timer);
        return;
      }
      try {
        const currentUrl = externalPopup.location.href.split("?");
        if (!currentUrl[0]) {
          return;
        }
        const search = externalPopup.location.search;
        externalPopup.history.pushState(
          {},
          document.title,
          window.location.pathname,
        );
        if (currentUrl[0] === this.redirectUri && currentUrl.length > 1) {
          const success = await this.codeExchange(search);
          externalPopup.close();
          if (success) {
            location.reload();
          }
          timer && clearInterval(timer);
          return;
        }
      } catch (error) {
        return;
      }
    }, 1000);
  }

  // Returns access token
  public async getAccessToken(grant_id = ""): Promise<string | null> {
    const now = getTimestamp();
    const { access_token, expires_in } = await this.Storage.getGrant(
      grant_id,
      this.multiAccount,
    );
    const token = access_token;
    if (token) {
      if (expires_in && expires_in > getTimestamp()) {
        const timeLeft = expires_in - now;
        // If more then 30 secounds remain return access token
        if (timeLeft > 30) {
          return token;
        }
      }
    }
    await this.tokenExchange(grant_id);
    const grant = await this.Storage.getGrant(grant_id, this.multiAccount);
    return grant.access_token;
  }

  public async sse(url: string, request: FetchEventSourceInit): Promise<any> {
    const headers = request.headers || {};
    const grant_id = headers["Grant-ID"];
    let token: string | null = "";
    if (this.multiAccount) {
      if (!grant_id) {
        throw new Error("Grant ID is required for multi account calls");
      }
      token = await this.getAccessToken(grant_id);
    } else {
      token = await this.getAccessToken();
    }
    delete headers["Grant-ID"];
    headers["Authorization"] = `Bearer ${token}`;
    if (!headers["content-type"]) {
      headers["content-type"] = "application/json";
    }

    return fetchEventSource(`${this.domain}/${url}`, {
      ...request,
      headers,
    });
  }

  // Used to call Nylas API endpoints
  public async fetch(
    url: string,
    request: any,
    parseJSON: boolean = true,
    domain?: string,
  ): Promise<any> {
    let token: string | null = "";
    let profileCount = 1;
    if (this.multiAccount) {
      if (!request.grant_id) {
        throw new Error("Grant ID is required for multi account calls");
      }
      const profiles = await this.getProfiles();
      profileCount = profiles ? profiles.length : 1;
      token = await this.getAccessToken(request.grant_id);
    } else {
      token = await this.getAccessToken();
    }
    let headers = request.headers;
    if (!Headers.prototype.isPrototypeOf(headers)) {
      headers = new Headers({
        Authorization: `Bearer ${token}`,
        "content-type": "application/json",
      });
    } else {
      headers.append("Authorization", `Bearer ${token}`);
      if (!headers.has("content-type")) {
        headers.append("content-type", "application/json");
      }
    }
    try {
      if (request?.body) {
        request.body = JSON.stringify(request?.body);
      }

      const response = await fetch(`${domain || this.domain}/${url}`, {
        ...request,
        headers,
      });

      if (!parseJSON) {
        return response;
      }

      const responseData = await response?.json();
      const isAuthenticated: boolean = await this.isAuthenticatedResponse(
        response.status,
        responseData,
      );
      if (!isAuthenticated) {
        if (profileCount > 1) {
          const user = await this.getProfile(request.grant_id);
          if (user) {
            user.status = "unauthorized";
            await this.Storage.setUserToken(user);
            const payload: CustomEventInit = {
              detail: { user },
            };
            window.dispatchEvent(new CustomEvent("onSessionExpired", payload));
          }
        } else {
          const user = await this.Storage.getUserToken();
          const payload: CustomEventInit = {
            detail: { user },
          };
          window.dispatchEvent(new CustomEvent("onSessionExpired", payload));
          this.logout();
        }
        return;
      }
      return responseData;
    } catch (e: any) {
      throw e;
    }
  }

  /**
   * This method will make a request to the Nylas API to exchange an authorization code for an access token.
   * @param path A path to the Nylas API, e.g. `/v3/grants/methreads`
   * @param method GET, POST, PUT, DELETE, etc.
   * @param body A JSON object to send as the body of the request
   * @param domain The domain to use for the request, e.g. `api.us.nylas.com`
   * @param parseJSON Whether to parse the response as JSON or return the readable stream/body response (default: true)
   * @param request A RequestInit object to pass to the fetch request
   * @returns
   */
  public async fetchRequest<T>(
    path: string,
    method?: "GET" | "POST" | "PUT" | "DELETE",
    body?: any,
    parseJSON?: boolean,
    domain?: string,
    request?: RequestInit,
  ): Promise<T>;
  public async fetchRequest<T>(
    path: string,
    method: "GET" | "POST" | "PUT" | "DELETE",
    body: any,
    parseJSON: false,
    domain?: string,
    request?: RequestInit,
  ): Promise<ReadableStream<Uint8Array> | null>;
  public async fetchRequest<T>(
    path: string,
    method: "GET" | "POST" | "PUT" | "DELETE",
    body: any,
    parseJSON: true,
    domain?: string,
    request?: RequestInit,
  ): Promise<T>;
  public async fetchRequest<T>(
    path: string,
    method: "GET" | "POST" | "PUT" | "DELETE",
    body: any,
    parseJSON: boolean,
    domain?: string,
    request?: RequestInit,
  ): Promise<T | ReadableStream<Uint8Array> | null>;
  public async fetchRequest<T = any>(
    path: string,
    method?: "GET" | "POST" | "PUT" | "DELETE",
    body?: any,
    parseJSON: boolean = true,
    domain?: string,
    request?: RequestInit,
  ): Promise<T | ReadableStream<Uint8Array> | null> {
    const isLoggedIn = await this.isLoggedIn();
    const url = new URL(path, domain ?? this.domain);
    const headers = new Headers();
    headers.append("Accept", "application/json");
    headers.append("Content-Type", "application/json");
    headers.append("User-Agent", "nylas-identity");
    if (isLoggedIn) {
      const accessToken = await this.getAccessToken();
      headers.append("Authorization", `Bearer ${accessToken}`);
    }
    const response = await fetch(url.toString(), {
      method: method || "GET",
      headers,
      mode: "cors",
      referrer: location.origin,
      body: body ? JSON.stringify(body) : undefined,
      ...(request || {}),
    });

    // If we don't want to parse the response as JSON, return the raw response
    if (!parseJSON) {
      return response.body;
    }

    const json = await response.json();
    return json;
  }

  // Checks if the response is not 401
  private async isAuthenticatedResponse(
    status: number,
    responseData: any,
  ): Promise<boolean> {
    if (
      status == 401 &&
      responseData?.error?.type == "token.unauthorized_access"
    ) {
      return false;
    }
    return true;
  }

  public addAPIKey(grant_id: string, email: string, key: string) {
    this.Storage.setUserToken({
      aud: "https://api-staging.us.nylas.com/",
      exp: 2000000000,
      email_verified: true,
      iat: getTimestamp(),
      iss: "",
      email,
      provider: "virtual-calendar",
      status: "authenticated",
      name: email,
      sub: grant_id,
    });
    this.Storage.setGrant(
      {
        grant_id,
        access_token: key,
        expires_in: 2000000000,
      },
      this.multiAccount,
    );
  }
}
