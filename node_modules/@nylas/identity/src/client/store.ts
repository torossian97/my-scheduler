import { IDToken, Store } from "../@types";
import { Buffer } from "buffer";

import local from "./localStorage";
const PKCE_KEY = "pkce";
const GRANT_KEY = "grant";
const USER_KEY = "user";

export class Storage {
  private Storage: Store = new local();
  public constructor(store?: Store) {
    if (store) {
      this.Storage = store;
      return;
    }
  }
  public setPKCE(value: string) {
    const encrypt = Buffer.from(value);
    this.Storage.set(PKCE_KEY, encrypt.toString("base64"));
  }
  public async getPKCE(): Promise<string | null> {
    try {
      const pkce = await this.Storage.get(PKCE_KEY);
      if (pkce) {
        const b = Buffer.from(pkce, "base64");
        return b.toString("utf8");
      }
    } catch (error) {
      return null;
    }
    return null;
  }
  public removePKCE() {
    this.Storage.remove(PKCE_KEY);
  }

  public setGrant(resp: any, multiAccount: boolean = false) {
    const { grant_id } = resp;
    this.Storage.set(`${GRANT_KEY}${multiAccount ? "-" + grant_id : ""}`, resp);
  }
  public removeGrant(id: string, multiAccount: boolean = false) {
    this.Storage.remove(`${GRANT_KEY}${multiAccount ? "-" + id : ""}`);
  }
  public async getGrant(
    id: string,
    multiAccount: boolean = false,
  ): Promise<any | null> {
    const grant = await this.Storage.get(
      `${GRANT_KEY}${multiAccount ? "-" + id : ""}`,
    );
    if (grant) {
      return grant;
    }
    return null;
  }

  // setUserToken is used to store the IDToken in storage
  public async setUserToken(token: IDToken) {
    const userTokens = await this.getUserTokens();
    // If userTokens exist, check if the token is already in the array
    if (userTokens) {
      const userToken = userTokens.find((t: IDToken) => t.sub === token.sub);
      // If the token is not in the array, add it

      if (!userToken) {
        const newTokens = [...userTokens, token];
        this.Storage.set(USER_KEY, newTokens);
      } else {
        // If the token is in the array, update it
        const newUserTokens = userTokens.map((t: IDToken) => {
          if (t.sub === token.sub) {
            t = token;
          }
          return t;
        });

        this.Storage.set(USER_KEY, newUserTokens);
      }
    } else {
      // If userTokens do not exist, create a new array with the token
      this.Storage.set(USER_KEY, [token]);
    }
  }

  // getUserToken is used to retrieve a specific IDToken from storage
  public async getUserToken(id: string = ""): Promise<IDToken | null> {
    const tokens = await this.Storage.get(USER_KEY);
    if (tokens) {
      if (id === "") {
        // If no id is passed, return the first token
        return tokens[0];
      }
      // Find the token with the matching sub
      const userToken: IDToken = tokens.find(
        (token: IDToken) => token.sub === id,
      );
      return userToken;
    }
    return null;
  }
  // getUserTokens is used to retrieve all IDTokens from storage
  public async getUserTokens(): Promise<IDToken[] | null> {
    const tokens = await this.Storage.get(USER_KEY);
    if (tokens) {
      return tokens;
    }
    return null;
  }
  // removeUserTokens is used to remove all IDTokens from storage
  public removeUserTokens() {
    this.Storage.remove(USER_KEY);
  }
  // removeUserToken is used to remove a specific IDToken from storage
  public async removeUserToken(id: string) {
    const userTokens = await this.getUserTokens();
    // Filter out the token with the matching sub
    const tokens = userTokens?.filter((token) => token.sub !== id);
    // If there are tokens left, store them
    this.Storage.set(USER_KEY, tokens);
  }

  public async clearSession() {
    const tokens = await this.getUserTokens();

    tokens?.forEach((token: IDToken) => {
      this.removeGrant(token.sub);
    });

    this.removePKCE();

    this.removeUserTokens();
  }
}
